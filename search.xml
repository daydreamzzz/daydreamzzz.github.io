<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自言自语</title>
    <url>/2019/12/15/index/</url>
    <content><![CDATA[<p>又又又一次下定决心要好好写博客了，每次折腾半天，更换新主题，研究配置。最后都是坚持不了几天就放弃了。</p>
<p>这一次就不给自己立Flag了，随缘记录吧。</p>
<p>这个博客，以后会承载我大部分的生活，情感，记录。 主要内容还是工作，编程学习方面的。偶尔会更新一些自己生活中的经历与感想。</p>
<p>之所以起名叫<strong>自言自语</strong>，主要还是自己本身还是一个不善言辞的人，超级死宅，这个博客估计也不会有其他人看到， 所以，不小心进来看到这些的你，谢谢你的光临。</p>
<p>之前使用过各种其他的笔记工具，bitbucket,  oneNote, github, 为知笔记，有道云笔记，Notion.  也在博客园，CSDN写过一些， 最后还是感觉自己喜欢折腾， 还是希望能拥有一个属于自己的博客啊。</p>
<p>后续会慢慢将其他地方记录的日志，博文迁移到这里汇总， 也会继续好好更新这里， 努力加油吧。</p>
<p>最后，这个博客主题，使用的是<a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">hexo-theme-Wikitten</a>  真的很好看啊，感谢原作者的创作。</p>
]]></content>
  </entry>
  <entry>
    <title>Tomcat学习笔记(1) Tomcat简介及启动信息</title>
    <url>/2018/11/28/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%20Tomcat%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tomcat是一个开源的Servlet容器,属于Apache软件基金会旗下的项目。Tomcat由Java实现，所以其运行依赖于Java环境，运行Tomcat前需要正确安装JRE. </p>
<p>官方网站： <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p>
<p>之前在servlet笔记中说到Tomcat作为一个Servlet容器，最主要的功能就是监听端口，接收用户请求，然后解析请求，生成request和response对象，再传递给servlet进行处理，等servlet处理完毕后返回response,再讲返回的response返回给客户端。</p>
<p>那么Tomcat到底是怎样完成这样一个过程呢？它又由哪些组件组成，每一个组件都负责干什么呢?这就是接下来Tomcat系列笔记索要探讨的内容。</p>
<p>ps: 虽然网上各种大大小小的博客与分析代码层出不穷，但是自己却从来没有深入的去研究过，别人写的再好，也只能作为参考，自己真正去用了，去实践了，才能让自己深入的理解！</p>
<h2 id="Tomcat与Servlet-JSP之间的对应关系"><a href="#Tomcat与Servlet-JSP之间的对应关系" class="headerlink" title="Tomcat与Servlet,JSP之间的对应关系"></a>Tomcat与Servlet,JSP之间的对应关系</h2><p>不同的tomcat版本对应不同的servlet和jsp版本，版本之间的对应关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Servlet版本</th>
<th style="text-align:center">JSP版本</th>
<th style="text-align:center">Tomcat版本</th>
<th style="text-align:center">WebSocket</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.0</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">9.0.x</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">8.5.x</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">2.3</td>
<td style="text-align:center">8.0.x</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">2.2</td>
<td style="text-align:center">7.0.x</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td style="text-align:center">2.5</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">6.0.x(archived)</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">2.4</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">5.5.x(archived)</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">2.3</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">4.1.x(archived)</td>
<td style="text-align:center">N/A</td>
</tr>
</tbody>
</table>
<p>数据来源： <a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">http://tomcat.apache.org/whichversion.html</a></p>
<p>此份笔记记录时使用的是Tomcat8.5.35，windows10平台。</p>
<h2 id="主要目录"><a href="#主要目录" class="headerlink" title="主要目录"></a>主要目录</h2><p>从Tomcat官网下载完tomcat之后，解压tomcat可以看到tomcat的目录结构，其中一些关键的文件夹为</p>
<ul>
<li>/bin 启动与关闭其一些其他脚本存在的地方，其中<code>.sh</code>后缀的文件用于linux环境，<code>.bat</code>后缀的文件用于windows环境</li>
<li>/conf 系统配置文件所在，其中最重要的文件是server.xml</li>
<li>/logs 默认的日志文件存在此处</li>
<li>/webapps web应用存在的地方</li>
</ul>
<h2 id="CATALINA-HOME-and-CATALINA-BASE"><a href="#CATALINA-HOME-and-CATALINA-BASE" class="headerlink" title="CATALINA_HOME and CATALINA_BASE"></a>CATALINA_HOME and CATALINA_BASE</h2><p>在整个Tomcat文档中，引入了以下两个属性</p>
<ul>
<li><strong>CATALINA_HOME</strong>： 表示Tomcat安装的根目录，如<strong>/home/tomcat/apache-tomcat-9.0.10</strong>或<strong>C:\Program Files\apache-tomcat-9.0.10</strong></li>
<li><strong>CATALINA_BASE</strong>： 表示特定Tomcat实例的运行时配置的根。如果要在一台计算机上拥有多个Tomcat实例，就需要使用<strong>CATALINA_BASE</strong>属性。</li>
</ul>
<h1 id="从启动说起"><a href="#从启动说起" class="headerlink" title="从启动说起"></a>从启动说起</h1><h3 id="startup-bat"><a href="#startup-bat" class="headerlink" title="startup.bat"></a>startup.bat</h3><p>Tomcat的启动文件是bin目录下的<strong>startup.bat</strong>文件，linux为<strong>startup.sh</strong>。这个文件的功能主要是设置<code>CATALINA_HOME</code>的值，然后执行其下的<code>catalina.bat</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">rem this work for additional information regarding copyright ownership.</span><br><span class="line">rem The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">rem (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">rem the License.  You may obtain a copy of the License at</span><br><span class="line">rem</span><br><span class="line">rem     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">rem</span><br><span class="line">rem Unless required by applicable law or agreed to in writing, software</span><br><span class="line">rem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">rem See the License for the specific language governing permissions and</span><br><span class="line">rem limitations under the License.</span><br><span class="line"></span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line">rem Start script for the CATALINA Server</span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">setlocal</span><br><span class="line"></span><br><span class="line">rem Guess CATALINA_HOME if not defined</span><br><span class="line">set &quot;CURRENT_DIR=%cd%&quot;</span><br><span class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</span><br><span class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</span><br><span class="line">cd ..</span><br><span class="line">set &quot;CATALINA_HOME=%cd%&quot;</span><br><span class="line">cd &quot;%CURRENT_DIR%&quot;</span><br><span class="line">:gotHome</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</span><br><span class="line">echo The CATALINA_HOME environment variable is not defined correctly</span><br><span class="line">echo This environment variable is needed to run this program</span><br><span class="line">goto end</span><br><span class="line">:okHome</span><br><span class="line"></span><br><span class="line">set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;</span><br><span class="line"></span><br><span class="line">rem Check that target executable exists</span><br><span class="line">if exist &quot;%EXECUTABLE%&quot; goto okExec</span><br><span class="line">echo Cannot find &quot;%EXECUTABLE%&quot;</span><br><span class="line">echo This file is needed to run this program</span><br><span class="line">goto end</span><br><span class="line">:okExec</span><br><span class="line"></span><br><span class="line">rem Get remaining unshifted command line arguments and save them in the</span><br><span class="line">set CMD_LINE_ARGS=</span><br><span class="line">:setArgs</span><br><span class="line">if &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgs</span><br><span class="line">set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1</span><br><span class="line">shift</span><br><span class="line">goto setArgs</span><br><span class="line">:doneSetArgs</span><br><span class="line"></span><br><span class="line">call &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%</span><br><span class="line"></span><br><span class="line">:end</span><br></pre></td></tr></table></figure>
<p>解释： </p>
<p>第1行echo为打印命令，此处为关闭打印信息</p>
<p>接下来的rem为注释语法，主要是一些许可证（License）信息</p>
<p>第21行，设置环境变量,关于setLocal命令参照 <a href="https://www.jb51.net/article/36043.htm" target="_blank" rel="noopener">https://www.jb51.net/article/36043.htm</a></p>
<p>第24行需要注意，在Dos命令中，%cd%为当前路径，比如我的startup.bat文件在D:\develop_software\apache-tomcat-8.0.53\bin之下，那么此处的%cd%就为这个路径</p>
<p>第25-35行为设置<code>CATALINA_HOME</code>的路径，因为在28行中有一个<code>cd..</code>返回了上一层，那么此处设置的 <code>CATALINA_HOME</code>就为D:\develop_software\apache-tomcat-8.0.53</p>
<p>第38-45行，验证%CATALINA_HOME%\bin\catalina.bat是否存在，不存在则输出错误信息，存在则进入下一层，跳转到48行</p>
<p>第48-55行，设置<code>CMD_LINE_ARGS</code>的值</p>
<p>第56行，调用%EXECUTABLE%， 也就是%CATALINA_HOME%\bin\catalina.bat， 传递两个参数：start, %CMD_LINE_ARGS%</p>
<h3 id="catalina-bat"><a href="#catalina-bat" class="headerlink" title="catalina.bat"></a>catalina.bat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">rem this work for additional information regarding copyright ownership.</span><br><span class="line">rem The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">rem (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">rem the License.  You may obtain a copy of the License at</span><br><span class="line">rem</span><br><span class="line">rem     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">rem</span><br><span class="line">rem Unless required by applicable law or agreed to in writing, software</span><br><span class="line">rem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">rem See the License for the specific language governing permissions and</span><br><span class="line">rem limitations under the License.</span><br><span class="line"></span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line">rem Start/Stop Script for the CATALINA Server</span><br><span class="line">rem</span><br><span class="line">rem Environment Variable Prerequisites</span><br><span class="line">rem</span><br><span class="line">rem   Do not set the variables in this script. Instead put them into a script</span><br><span class="line">rem   setenv.bat in CATALINA_BASE/bin to keep your customizations separate.</span><br><span class="line">rem</span><br><span class="line">rem   WHEN RUNNING TOMCAT AS A WINDOWS SERVICE:</span><br><span class="line">rem   Note that the environment variables that affect the behavior of this</span><br><span class="line">rem   script will have no effect at all on Windows Services. As such, any</span><br><span class="line">rem   local customizations made in a CATALINA_BASE/bin/setenv.bat script</span><br><span class="line">rem   will also have no effect on Tomcat when launched as a Windows Service.</span><br><span class="line">rem   The configuration that controls Windows Services is stored in the Windows</span><br><span class="line">rem   Registry, and is most conveniently maintained using the &quot;tomcatXw.exe&quot;</span><br><span class="line">rem   maintenance utility, where &quot;X&quot; is the major version of Tomcat you are</span><br><span class="line">rem   running.</span><br><span class="line">rem</span><br><span class="line">rem   CATALINA_HOME   May point at your Catalina &quot;build&quot; directory.</span><br><span class="line">rem</span><br><span class="line">rem   CATALINA_BASE   (Optional) Base directory for resolving dynamic portions</span><br><span class="line">rem                   of a Catalina installation.  If not present, resolves to</span><br><span class="line">rem                   the same directory that CATALINA_HOME points to.</span><br><span class="line">rem</span><br><span class="line">rem   CATALINA_OPTS   (Optional) Java runtime options used when the &quot;start&quot;,</span><br><span class="line">rem                   &quot;run&quot; or &quot;debug&quot; command is executed.</span><br><span class="line">rem                   Include here and not in JAVA_OPTS all options, that should</span><br><span class="line">rem                   only be used by Tomcat itself, not by the stop process,</span><br><span class="line">rem                   the version command etc.</span><br><span class="line">rem                   Examples are heap size, GC logging, JMX ports etc.</span><br><span class="line">rem</span><br><span class="line">rem   CATALINA_TMPDIR (Optional) Directory path location of temporary directory</span><br><span class="line">rem                   the JVM should use (java.io.tmpdir).  Defaults to</span><br><span class="line">rem                   %CATALINA_BASE%\temp.</span><br><span class="line">rem</span><br><span class="line">rem   JAVA_HOME       Must point at your Java Development Kit installation.</span><br><span class="line">rem                   Required to run the with the &quot;debug&quot; argument.</span><br><span class="line">rem</span><br><span class="line">rem   JRE_HOME        Must point at your Java Runtime installation.</span><br><span class="line">rem                   Defaults to JAVA_HOME if empty. If JRE_HOME and JAVA_HOME</span><br><span class="line">rem                   are both set, JRE_HOME is used.</span><br><span class="line">rem</span><br><span class="line">rem   JAVA_OPTS       (Optional) Java runtime options used when any command</span><br><span class="line">rem                   is executed.</span><br><span class="line">rem                   Include here and not in CATALINA_OPTS all options, that</span><br><span class="line">rem                   should be used by Tomcat and also by the stop process,</span><br><span class="line">rem                   the version command etc.</span><br><span class="line">rem                   Most options should go into CATALINA_OPTS.</span><br><span class="line">rem</span><br><span class="line">rem   JAVA_ENDORSED_DIRS (Optional) Lists of of semi-colon separated directories</span><br><span class="line">rem                   containing some jars in order to allow replacement of APIs</span><br><span class="line">rem                   created outside of the JCP (i.e. DOM and SAX from W3C).</span><br><span class="line">rem                   It can also be used to update the XML parser implementation.</span><br><span class="line">rem                   Note that Java 9 no longer supports this feature.</span><br><span class="line">rem                   Defaults to $CATALINA_HOME/endorsed.</span><br><span class="line">rem</span><br><span class="line">rem   JPDA_TRANSPORT  (Optional) JPDA transport used when the &quot;jpda start&quot;</span><br><span class="line">rem                   command is executed. The default is &quot;dt_socket&quot;.</span><br><span class="line">rem</span><br><span class="line">rem   JPDA_ADDRESS    (Optional) Java runtime options used when the &quot;jpda start&quot;</span><br><span class="line">rem                   command is executed. The default is localhost:8000.</span><br><span class="line">rem</span><br><span class="line">rem   JPDA_SUSPEND    (Optional) Java runtime options used when the &quot;jpda start&quot;</span><br><span class="line">rem                   command is executed. Specifies whether JVM should suspend</span><br><span class="line">rem                   execution immediately after startup. Default is &quot;n&quot;.</span><br><span class="line">rem</span><br><span class="line">rem   JPDA_OPTS       (Optional) Java runtime options used when the &quot;jpda start&quot;</span><br><span class="line">rem                   command is executed. If used, JPDA_TRANSPORT, JPDA_ADDRESS,</span><br><span class="line">rem                   and JPDA_SUSPEND are ignored. Thus, all required jpda</span><br><span class="line">rem                   options MUST be specified. The default is:</span><br><span class="line">rem</span><br><span class="line">rem                   -agentlib:jdwp=transport=%JPDA_TRANSPORT%,</span><br><span class="line">rem                       address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%</span><br><span class="line">rem</span><br><span class="line">rem   JSSE_OPTS       (Optional) Java runtime options used to control the TLS</span><br><span class="line">rem                   implementation when JSSE is used. Default is:</span><br><span class="line">rem                   &quot;-Djdk.tls.ephemeralDHKeySize=2048&quot;</span><br><span class="line">rem</span><br><span class="line">rem   LOGGING_CONFIG  (Optional) Override Tomcat&apos;s logging config file</span><br><span class="line">rem                   Example (all one line)</span><br><span class="line">rem                   set LOGGING_CONFIG=&quot;-Djava.util.logging.config.file=%CATALINA_BASE%\conf\logging.properties&quot;</span><br><span class="line">rem</span><br><span class="line">rem   LOGGING_MANAGER (Optional) Override Tomcat&apos;s logging manager</span><br><span class="line">rem                   Example (all one line)</span><br><span class="line">rem                   set LOGGING_MANAGER=&quot;-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager&quot;</span><br><span class="line">rem</span><br><span class="line">rem   TITLE           (Optional) Specify the title of Tomcat window. The default</span><br><span class="line">rem                   TITLE is Tomcat if it&apos;s not specified.</span><br><span class="line">rem                   Example (all one line)</span><br><span class="line">rem                   set TITLE=Tomcat.Cluster#1.Server#1 [%DATE% %TIME%]</span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">setlocal</span><br><span class="line"></span><br><span class="line">rem Suppress Terminate batch job on CTRL+C</span><br><span class="line">if not &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto mainEntry</span><br><span class="line">if &quot;%TEMP%&quot; == &quot;&quot; goto mainEntry</span><br><span class="line">if exist &quot;%TEMP%\%~nx0.run&quot; goto mainEntry</span><br><span class="line">echo Y&gt;&quot;%TEMP%\%~nx0.run&quot;</span><br><span class="line">if not exist &quot;%TEMP%\%~nx0.run&quot; goto mainEntry</span><br><span class="line">echo Y&gt;&quot;%TEMP%\%~nx0.Y&quot;</span><br><span class="line">call &quot;%~f0&quot; %* &lt;&quot;%TEMP%\%~nx0.Y&quot;</span><br><span class="line">rem Use provided errorlevel</span><br><span class="line">set RETVAL=%ERRORLEVEL%</span><br><span class="line">del /Q &quot;%TEMP%\%~nx0.Y&quot; &gt;NUL 2&gt;&amp;1</span><br><span class="line">exit /B %RETVAL%</span><br><span class="line">:mainEntry</span><br><span class="line">del /Q &quot;%TEMP%\%~nx0.run&quot; &gt;NUL 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">rem Guess CATALINA_HOME if not defined</span><br><span class="line">set &quot;CURRENT_DIR=%cd%&quot;</span><br><span class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</span><br><span class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</span><br><span class="line">cd ..</span><br><span class="line">set &quot;CATALINA_HOME=%cd%&quot;</span><br><span class="line">cd &quot;%CURRENT_DIR%&quot;</span><br><span class="line">:gotHome</span><br><span class="line"></span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</span><br><span class="line">echo The CATALINA_HOME environment variable is not defined correctly</span><br><span class="line">echo This environment variable is needed to run this program</span><br><span class="line">goto end</span><br><span class="line">:okHome</span><br><span class="line"></span><br><span class="line">rem Copy CATALINA_BASE from CATALINA_HOME if not defined</span><br><span class="line">if not &quot;%CATALINA_BASE%&quot; == &quot;&quot; goto gotBase</span><br><span class="line">set &quot;CATALINA_BASE=%CATALINA_HOME%&quot;</span><br><span class="line">:gotBase</span><br><span class="line"></span><br><span class="line">rem Ensure that neither CATALINA_HOME nor CATALINA_BASE contains a semi-colon</span><br><span class="line">rem as this is used as the separator in the classpath and Java provides no</span><br><span class="line">rem mechanism for escaping if the same character appears in the path. Check this</span><br><span class="line">rem by replacing all occurrences of &apos;;&apos; with &apos;&apos; and checking that neither</span><br><span class="line">rem CATALINA_HOME nor CATALINA_BASE have changed</span><br><span class="line">if &quot;%CATALINA_HOME%&quot; == &quot;%CATALINA_HOME:;=%&quot; goto homeNoSemicolon</span><br><span class="line">echo Using CATALINA_HOME:   &quot;%CATALINA_HOME%&quot;</span><br><span class="line">echo Unable to start as CATALINA_HOME contains a semicolon (;) character</span><br><span class="line">goto end</span><br><span class="line">:homeNoSemicolon</span><br><span class="line"></span><br><span class="line">if &quot;%CATALINA_BASE%&quot; == &quot;%CATALINA_BASE:;=%&quot; goto baseNoSemicolon</span><br><span class="line">echo Using CATALINA_BASE:   &quot;%CATALINA_BASE%&quot;</span><br><span class="line">echo Unable to start as CATALINA_BASE contains a semicolon (;) character</span><br><span class="line">goto end</span><br><span class="line">:baseNoSemicolon</span><br><span class="line"></span><br><span class="line">rem Ensure that any user defined CLASSPATH variables are not used on startup,</span><br><span class="line">rem but allow them to be specified in setenv.bat, in rare case when it is needed.</span><br><span class="line">set CLASSPATH=</span><br><span class="line"></span><br><span class="line">rem Get standard environment variables</span><br><span class="line">if not exist &quot;%CATALINA_BASE%\bin\setenv.bat&quot; goto checkSetenvHome</span><br><span class="line">call &quot;%CATALINA_BASE%\bin\setenv.bat&quot;</span><br><span class="line">goto setenvDone</span><br><span class="line">:checkSetenvHome</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\setenv.bat&quot; call &quot;%CATALINA_HOME%\bin\setenv.bat&quot;</span><br><span class="line">:setenvDone</span><br><span class="line"></span><br><span class="line">rem Get standard Java environment variables</span><br><span class="line">if exist &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; goto okSetclasspath</span><br><span class="line">echo Cannot find &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot;</span><br><span class="line">echo This file is needed to run this program</span><br><span class="line">goto end</span><br><span class="line">:okSetclasspath</span><br><span class="line">call &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; %1</span><br><span class="line">if errorlevel 1 goto end</span><br><span class="line"></span><br><span class="line">rem Add on extra jar file to CLASSPATH</span><br><span class="line">rem Note that there are no quotes as we do not want to introduce random</span><br><span class="line">rem quotes into the CLASSPATH</span><br><span class="line">if &quot;%CLASSPATH%&quot; == &quot;&quot; goto emptyClasspath</span><br><span class="line">set &quot;CLASSPATH=%CLASSPATH%;&quot;</span><br><span class="line">:emptyClasspath</span><br><span class="line">set &quot;CLASSPATH=%CLASSPATH%%CATALINA_HOME%\bin\bootstrap.jar&quot;</span><br><span class="line"></span><br><span class="line">if not &quot;%CATALINA_TMPDIR%&quot; == &quot;&quot; goto gotTmpdir</span><br><span class="line">set &quot;CATALINA_TMPDIR=%CATALINA_BASE%\temp&quot;</span><br><span class="line">:gotTmpdir</span><br><span class="line"></span><br><span class="line">rem Add tomcat-juli.jar to classpath</span><br><span class="line">rem tomcat-juli.jar can be over-ridden per instance</span><br><span class="line">if not exist &quot;%CATALINA_BASE%\bin\tomcat-juli.jar&quot; goto juliClasspathHome</span><br><span class="line">set &quot;CLASSPATH=%CLASSPATH%;%CATALINA_BASE%\bin\tomcat-juli.jar&quot;</span><br><span class="line">goto juliClasspathDone</span><br><span class="line">:juliClasspathHome</span><br><span class="line">set &quot;CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\bin\tomcat-juli.jar&quot;</span><br><span class="line">:juliClasspathDone</span><br><span class="line"></span><br><span class="line">if not &quot;%JSSE_OPTS%&quot; == &quot;&quot; goto gotJsseOpts</span><br><span class="line">set JSSE_OPTS=&quot;-Djdk.tls.ephemeralDHKeySize=2048&quot;</span><br><span class="line">:gotJsseOpts</span><br><span class="line">set &quot;JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%&quot;</span><br><span class="line"></span><br><span class="line">rem Register custom URL handlers</span><br><span class="line">rem Do this here so custom URL handles (specifically &apos;war:...&apos;) can be used in the security policy</span><br><span class="line">set &quot;JAVA_OPTS=%JAVA_OPTS% -Djava.protocol.handler.pkgs=org.apache.catalina.webresources&quot;</span><br><span class="line"></span><br><span class="line">if not &quot;%LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Dnop</span><br><span class="line">if not exist &quot;%CATALINA_BASE%\conf\logging.properties&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\conf\logging.properties&quot;</span><br><span class="line">:noJuliConfig</span><br><span class="line"></span><br><span class="line">if not &quot;%LOGGING_MANAGER%&quot; == &quot;&quot; goto noJuliManager</span><br><span class="line">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">:noJuliManager</span><br><span class="line"></span><br><span class="line">rem Configure JAVA 9 specific start-up parameters</span><br><span class="line">set &quot;JDK_JAVA_OPTIONS=%JDK_JAVA_OPTIONS% --add-opens=java.base/java.lang=ALL-UNNAMED&quot;</span><br><span class="line">set &quot;JDK_JAVA_OPTIONS=%JDK_JAVA_OPTIONS% --add-opens=java.base/java.io=ALL-UNNAMED&quot;</span><br><span class="line">set &quot;JDK_JAVA_OPTIONS=%JDK_JAVA_OPTIONS% --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED&quot;</span><br><span class="line"></span><br><span class="line">rem Java 9 no longer supports the java.endorsed.dirs</span><br><span class="line">rem system property. Only try to use it if</span><br><span class="line">rem JAVA_ENDORSED_DIRS was explicitly set</span><br><span class="line">rem or CATALINA_HOME/endorsed exists.</span><br><span class="line">set ENDORSED_PROP=ignore.endorsed.dirs</span><br><span class="line">if &quot;%JAVA_ENDORSED_DIRS%&quot; == &quot;&quot; goto noEndorsedVar</span><br><span class="line">set ENDORSED_PROP=java.endorsed.dirs</span><br><span class="line">goto doneEndorsed</span><br><span class="line">:noEndorsedVar</span><br><span class="line">if not exist &quot;%CATALINA_HOME%\endorsed&quot; goto doneEndorsed</span><br><span class="line">set ENDORSED_PROP=java.endorsed.dirs</span><br><span class="line">:doneEndorsed</span><br><span class="line"></span><br><span class="line">rem ----- Execute The Requested Command ---------------------------------------</span><br><span class="line"></span><br><span class="line">echo Using CATALINA_BASE:   &quot;%CATALINA_BASE%&quot;</span><br><span class="line">echo Using CATALINA_HOME:   &quot;%CATALINA_HOME%&quot;</span><br><span class="line">echo Using CATALINA_TMPDIR: &quot;%CATALINA_TMPDIR%&quot;</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto use_jdk</span><br><span class="line">echo Using JRE_HOME:        &quot;%JRE_HOME%&quot;</span><br><span class="line">goto java_dir_displayed</span><br><span class="line">:use_jdk</span><br><span class="line">echo Using JAVA_HOME:       &quot;%JAVA_HOME%&quot;</span><br><span class="line">:java_dir_displayed</span><br><span class="line">echo Using CLASSPATH:       &quot;%CLASSPATH%&quot;</span><br><span class="line"></span><br><span class="line">set _EXECJAVA=%_RUNJAVA%</span><br><span class="line">set MAINCLASS=org.apache.catalina.startup.Bootstrap</span><br><span class="line">set ACTION=start</span><br><span class="line">set SECURITY_POLICY_FILE=</span><br><span class="line">set DEBUG_OPTS=</span><br><span class="line">set JPDA=</span><br><span class="line"></span><br><span class="line">if not &quot;&quot;%1&quot;&quot; == &quot;&quot;jpda&quot;&quot; goto noJpda</span><br><span class="line">set JPDA=jpda</span><br><span class="line">if not &quot;%JPDA_TRANSPORT%&quot; == &quot;&quot; goto gotJpdaTransport</span><br><span class="line">set JPDA_TRANSPORT=dt_socket</span><br><span class="line">:gotJpdaTransport</span><br><span class="line">if not &quot;%JPDA_ADDRESS%&quot; == &quot;&quot; goto gotJpdaAddress</span><br><span class="line">set JPDA_ADDRESS=localhost:8000</span><br><span class="line">:gotJpdaAddress</span><br><span class="line">if not &quot;%JPDA_SUSPEND%&quot; == &quot;&quot; goto gotJpdaSuspend</span><br><span class="line">set JPDA_SUSPEND=n</span><br><span class="line">:gotJpdaSuspend</span><br><span class="line">if not &quot;%JPDA_OPTS%&quot; == &quot;&quot; goto gotJpdaOpts</span><br><span class="line">set JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND%</span><br><span class="line">:gotJpdaOpts</span><br><span class="line">shift</span><br><span class="line">:noJpda</span><br><span class="line"></span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto doDebug</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto doRun</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;start&quot;&quot; goto doStart</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;stop&quot;&quot; goto doStop</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;configtest&quot;&quot; goto doConfigTest</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;version&quot;&quot; goto doVersion</span><br><span class="line"></span><br><span class="line">echo Usage:  catalina ( commands ... )</span><br><span class="line">echo commands:</span><br><span class="line">echo   debug             Start Catalina in a debugger</span><br><span class="line">echo   debug -security   Debug Catalina with a security manager</span><br><span class="line">echo   jpda start        Start Catalina under JPDA debugger</span><br><span class="line">echo   run               Start Catalina in the current window</span><br><span class="line">echo   run -security     Start in the current window with security manager</span><br><span class="line">echo   start             Start Catalina in a separate window</span><br><span class="line">echo   start -security   Start in a separate window with security manager</span><br><span class="line">echo   stop              Stop Catalina</span><br><span class="line">echo   configtest        Run a basic syntax check on server.xml</span><br><span class="line">echo   version           What version of tomcat are you running?</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:doDebug</span><br><span class="line">shift</span><br><span class="line">set _EXECJAVA=%_RUNJDB%</span><br><span class="line">set DEBUG_OPTS=-sourcepath &quot;%CATALINA_HOME%\..\..\java&quot;</span><br><span class="line">if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd</span><br><span class="line">shift</span><br><span class="line">echo Using Security Manager</span><br><span class="line">set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;</span><br><span class="line">goto execCmd</span><br><span class="line"></span><br><span class="line">:doRun</span><br><span class="line">shift</span><br><span class="line">if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd</span><br><span class="line">shift</span><br><span class="line">echo Using Security Manager</span><br><span class="line">set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;</span><br><span class="line">goto execCmd</span><br><span class="line"></span><br><span class="line">:doStart</span><br><span class="line">shift</span><br><span class="line">if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat</span><br><span class="line">set _EXECJAVA=start &quot;%TITLE%&quot; %_RUNJAVA%</span><br><span class="line">if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd</span><br><span class="line">shift</span><br><span class="line">echo Using Security Manager</span><br><span class="line">set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;</span><br><span class="line">goto execCmd</span><br><span class="line"></span><br><span class="line">:doStop</span><br><span class="line">shift</span><br><span class="line">set ACTION=stop</span><br><span class="line">set CATALINA_OPTS=</span><br><span class="line">goto execCmd</span><br><span class="line"></span><br><span class="line">:doConfigTest</span><br><span class="line">shift</span><br><span class="line">set ACTION=configtest</span><br><span class="line">set CATALINA_OPTS=</span><br><span class="line">goto execCmd</span><br><span class="line"></span><br><span class="line">:doVersion</span><br><span class="line">%_EXECJAVA% -classpath &quot;%CATALINA_HOME%\lib\catalina.jar&quot; org.apache.catalina.util.ServerInfo</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:execCmd</span><br><span class="line">rem Get remaining unshifted command line arguments and save them in the</span><br><span class="line">set CMD_LINE_ARGS=</span><br><span class="line">:setArgs</span><br><span class="line">if &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgs</span><br><span class="line">set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1</span><br><span class="line">shift</span><br><span class="line">goto setArgs</span><br><span class="line">:doneSetArgs</span><br><span class="line"></span><br><span class="line">rem Execute Java with the applicable properties</span><br><span class="line">if not &quot;%JPDA%&quot; == &quot;&quot; goto doJpda</span><br><span class="line">if not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurity</span><br><span class="line">%_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%</span><br><span class="line">goto end</span><br><span class="line">:doSecurity</span><br><span class="line">%_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%</span><br><span class="line">goto end</span><br><span class="line">:doJpda</span><br><span class="line">if not &quot;%SECURITY_POLICY_FILE%&quot; == &quot;&quot; goto doSecurityJpda</span><br><span class="line">%_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%</span><br><span class="line">goto end</span><br><span class="line">:doSecurityJpda</span><br><span class="line">%_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %JPDA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Djava.security.manager -Djava.security.policy==&quot;%SECURITY_POLICY_FILE%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:end</span><br></pre></td></tr></table></figure>
<p>第1行与第109行不用细看，从第112行开始</p>
<p>第112行到122： 这之间的代码都为参数校验，具体的参数详情我也并没有详细了解过</p>
<p>第123-139： 校验<code>CATALINA_HOME</code>和<code>%CATALINA_HOME%\bin\catalina.bat</code>, 由于我们已经在<code>startup.bat</code>中确认了这两个参数的存在，所以会直接从136行的判断中跳转到140行的okHome</p>
<p>第140-144： 设置<code>CATALINA_BASE</code>这个变量的值，因为本身不存在，所以143行的判断为false,在144行设置其值为<code>%CATALINA_HOME%</code>, 然后代码接着往下走，进入第152行</p>
<p>第152-161行： 这里我并不知道152和158中的<code>%CATALINA_BASE:;=%</code>的值是什么，但是猜想一下：已知条件<code>CATALINA_BASE</code>和<code>CATALINA_HOME</code>目前是同一个值，如果152行if判断为false, 不进行跳转，那么会接着执行，在155会结束这个文件，那么接下来的所有代码都没什么意义了，所以这里的if判断应该是true,相应的在158行也为true, 进入162行</p>
<p>第162-174： 这里定义了一个变量<code>CLASSPATH</code>，然后判断<code>CATALINA_BASE%\bin\setenv.bat</code>这个文件是否存在，如果存在，执行它。这次因为我们下载下来并没有这个文件，接着往下再看.</p>
<p>第175-182： 判断<code>%CATALINA_HOME%\bin\setclasspath.bat</code>这个文件是否存在，存在则执行，不存在直接退出。 因为当前系统中有这个文件，所以并不会在此退出，关于<code>setclasspath.bat</code>这个文件，后面会详细说明，下面先继续往下执行. 这个文件的主要作用是验证Java环境变量，即<code>JAVA_HOME</code>的值，并定义了<code>_RUNJAVA</code>的值</p>
<p>第183-262：设置了一堆变量，这里183的判断errorLevel是什么意思，我并不清楚，但是如果为true,直接结束了这个文件，所以应该会继续往下走。此处需要注意，在这里面有一处设置变量的地方有一些问题，即第256行处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set _EXECJAVA=%_RUNJAVA%</span><br></pre></td></tr></table></figure>
<p>这个地方<code>_RUNJAVA</code>并没有值，这里先跳过，后面再说。</p>
<p>第263-345： 这一段前面也是设置值，然后进行判断，中间有一段打印信息。这些都不用追究太深，需要注意的是在这一段代码最终会进入到346行这个标记execCmd，在这里第322行也可以看到这个变量<code>_RUNJAVA</code>,依然没有值。在这处对于<code>_RUNJAVA</code>这个值进行了更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set _EXECJAVA=start &quot;%TITLE%&quot; %_RUNJAVA%</span><br></pre></td></tr></table></figure>
<p>需要注意： start是一个dos命令，可参考：<a href="https://blog.csdn.net/mydriverc/article/details/2049347。" target="_blank" rel="noopener">https://blog.csdn.net/mydriverc/article/details/2049347。</a> 这里把<code>_EXECJAVA</code>这个变量设置成了一个dos命令，并为它传递了第一个参数<code>%TITLE%</code>, 那么既然是个命令，必然有其存在的作用，我们后面再说。</p>
<p>第346-354：设置变量<code>CMD_LINE_ARGS</code>的值，然后继续往下。</p>
<p>第355-372：这一块的代码就主要围绕<code>_RUNJAVA</code>这个参数来进行了，前面将这个参数设置成了一个命令<strong>start</strong>，那么在这一块就是调用它的时候， 而后面所接的内容，都是这个命令所传的参数。 而这一块正常执行的代码在第359行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%_EXECJAVA% %LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%</span><br></pre></td></tr></table></figure>
<p>start命令传递的第一个参数为新打开窗口的标题参数，这个已经在322行设置过了，后面所有一长串参数一直到倒数第三个参数，为这个命令所携带的参数。 在这里我们需要注意的是末尾的参数<code>%MAINCLASS%</code>和<code>%CMD_LINE_ARGS% %ACTION%</code>。</p>
<p>在<code>%MAINCLASS%</code>这个变量是在257行定义的，值为<code>org.apache.catalina.startup.Bootstrap</code>, 所以我们最后页说<strong>Tomcat的启动最终是启动<code>org.apache.catalina.startup.Bootstrap</code>这个类中的方法</strong>。</p>
<h3 id="setclasspath-bat"><a href="#setclasspath-bat" class="headerlink" title="setclasspath.bat"></a>setclasspath.bat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">rem contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">rem this work for additional information regarding copyright ownership.</span><br><span class="line">rem The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">rem (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">rem the License.  You may obtain a copy of the License at</span><br><span class="line">rem</span><br><span class="line">rem     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">rem</span><br><span class="line">rem Unless required by applicable law or agreed to in writing, software</span><br><span class="line">rem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">rem See the License for the specific language governing permissions and</span><br><span class="line">rem limitations under the License.</span><br><span class="line"></span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line">rem Set JAVA_HOME or JRE_HOME if not already set, ensure any provided settings</span><br><span class="line">rem are valid and consistent with the selected start-up options and set up the</span><br><span class="line">rem endorsed directory.</span><br><span class="line">rem ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">rem Make sure prerequisite environment variables are set</span><br><span class="line"></span><br><span class="line">rem In debug mode we need a real JDK (JAVA_HOME)</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto needJavaHome</span><br><span class="line"></span><br><span class="line">rem Otherwise either JRE or JDK are fine</span><br><span class="line">if not &quot;%JRE_HOME%&quot; == &quot;&quot; goto gotJreHome</span><br><span class="line">if not &quot;%JAVA_HOME%&quot; == &quot;&quot; goto gotJavaHome</span><br><span class="line">echo Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">echo At least one of these environment variable is needed to run this program</span><br><span class="line">goto exit</span><br><span class="line"></span><br><span class="line">:needJavaHome</span><br><span class="line">rem Check if we have a usable JDK</span><br><span class="line">if &quot;%JAVA_HOME%&quot; == &quot;&quot; goto noJavaHome</span><br><span class="line">if not exist &quot;%JAVA_HOME%\bin\java.exe&quot; goto noJavaHome</span><br><span class="line">if not exist &quot;%JAVA_HOME%\bin\jdb.exe&quot; goto noJavaHome</span><br><span class="line">if not exist &quot;%JAVA_HOME%\bin\javac.exe&quot; goto noJavaHome</span><br><span class="line">set &quot;JRE_HOME=%JAVA_HOME%&quot;</span><br><span class="line">goto okJava</span><br><span class="line"></span><br><span class="line">:noJavaHome</span><br><span class="line">echo The JAVA_HOME environment variable is not defined correctly.</span><br><span class="line">echo It is needed to run this program in debug mode.</span><br><span class="line">echo NB: JAVA_HOME should point to a JDK not a JRE.</span><br><span class="line">goto exit</span><br><span class="line"></span><br><span class="line">:gotJavaHome</span><br><span class="line">rem No JRE given, use JAVA_HOME as JRE_HOME</span><br><span class="line">set &quot;JRE_HOME=%JAVA_HOME%&quot;</span><br><span class="line"></span><br><span class="line">:gotJreHome</span><br><span class="line">rem Check if we have a usable JRE</span><br><span class="line">if not exist &quot;%JRE_HOME%\bin\java.exe&quot; goto noJreHome</span><br><span class="line">goto okJava</span><br><span class="line"></span><br><span class="line">:noJreHome</span><br><span class="line">rem Needed at least a JRE</span><br><span class="line">echo The JRE_HOME environment variable is not defined correctly</span><br><span class="line">echo This environment variable is needed to run this program</span><br><span class="line">goto exit</span><br><span class="line"></span><br><span class="line">:okJava</span><br><span class="line">rem Don&apos;t override the endorsed dir if the user has set it previously</span><br><span class="line">if not &quot;%JAVA_ENDORSED_DIRS%&quot; == &quot;&quot; goto gotEndorseddir</span><br><span class="line">rem Java 9 no longer supports the java.endorsed.dirs</span><br><span class="line">rem system property. Only try to use it if</span><br><span class="line">rem CATALINA_HOME/endorsed exists.</span><br><span class="line">if not exist &quot;%CATALINA_HOME%\endorsed&quot; goto gotEndorseddir</span><br><span class="line">set &quot;JAVA_ENDORSED_DIRS=%CATALINA_HOME%\endorsed&quot;</span><br><span class="line">:gotEndorseddir</span><br><span class="line"></span><br><span class="line">rem Don&apos;t override _RUNJAVA if the user has set it previously</span><br><span class="line">if not &quot;%_RUNJAVA%&quot; == &quot;&quot; goto gotRunJava</span><br><span class="line">rem Set standard command for invoking Java.</span><br><span class="line">rem Also note the quoting as JRE_HOME may contain spaces.</span><br><span class="line">set _RUNJAVA=&quot;%JRE_HOME%\bin\java.exe&quot;</span><br><span class="line">:gotRunJava</span><br><span class="line"></span><br><span class="line">rem Don&apos;t override _RUNJDB if the user has set it previously</span><br><span class="line">rem Also note the quoting as JAVA_HOME may contain spaces.</span><br><span class="line">if not &quot;%_RUNJDB%&quot; == &quot;&quot; goto gotRunJdb</span><br><span class="line">set _RUNJDB=&quot;%JAVA_HOME%\bin\jdb.exe&quot;</span><br><span class="line">:gotRunJdb</span><br><span class="line"></span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:exit</span><br><span class="line">exit /b 1</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line">exit /b 0</span><br></pre></td></tr></table></figure>
<p>第1-63行： 判断Java环境变量是否存在，即验证<code>%JAVA_HOME%</code>的值，如果不存在直接退出。</p>
<p>第64-86行： 验证一些文件是否存在，最后设置<code>_RUNJDB</code>的值，在第85行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set _RUNJDB=&quot;%JAVA_HOME%\bin\jdb.exe&quot;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于本人对于dos命令的理解也并不深刻，上面对于Tomcat的启动文件分析可能会有一定的错误，但是大致流程应该是对的，如果有什么错误的地方，请为我指出，谢谢。</p>
<p>既然已经知道Tomcat启动最终会执行<code>org.apache.catalina.startup.Bootstrap</code>，下一篇再来详细看一看这个类中的方法。</p>
<p>### </p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>服务器</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb开发学习笔记之Servlet（四） Filter与Listener</title>
    <url>/2018/11/21/Servlet(4)Filter%E4%B8%8EListener/</url>
    <content><![CDATA[<h1 id="Filter简介"><a href="#Filter简介" class="headerlink" title="Filter简介"></a>Filter简介</h1><p>Filter过滤器，其作用是请求到达servlet之前对其进行过滤，对其进行预处理，在servlet对于请求处理完毕返回后对响应对象进行后处理。</p>
<p>Filter本身并不申请请求对象(Request)和响应对象(Response)， 只提供过滤功能。</p>
<p>Filter是Servlet三大组件(Servlet,Filter,Listener)之一,是设计模式中<strong>过滤器模式</strong>的体现</p>
<h2 id="创建Filter"><a href="#创建Filter" class="headerlink" title="创建Filter"></a>创建Filter</h2><p>Filter的创建和Servlet的创建方式大同小异。创建Filter处理类，在web.xml中进行配置。 所有servlet filter过滤器都需要实现javax.servlet.Filter接口，并实现该接口中的三个方法</p>
<ul>
<li>init(FilterConfig filterConfig)</li>
<li>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</li>
<li>destroy()</li>
</ul>
<p>例子，配置一个简单的Filter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoginFilter implements Filter&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;filter init...&quot;);</span><br><span class="line">		// Filter创建时调用此方法进行初始化, filterConfig的用法和ServletConfig类似</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">			throws IOException, ServletException &#123;</span><br><span class="line">		// 进入servlet之前调用</span><br><span class="line">		System.out.println(&quot;before enter servlet&quot;);</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">		System.out.println(&quot;after servlet&quot;);</span><br><span class="line">		// 处理之后调用</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		// 当前Filter声明周期结束，调用此方法释放销毁</span><br><span class="line">		System.out.println(&quot;destroy...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在web.xml中配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;loginFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;cn.hel.util.LoginFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;loginFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/login&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>关于Filter的配置， 在servlet3.0以上的版本中增加了注解配置，无需继续在web.xml中进行配置，直接在类上使用@WebFilter注解即可，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebFilter(filterName=&quot;loginFilter&quot;,urlPatterns=&quot;/hello&quot;)</span><br><span class="line">public class LoginFilter implements Filter&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于@WebFilter注解与web.xml中配置Filter的属性对照,<strong>@WebFilter注解的属性都为可选属性，但是value或者urlPatterns,servletNames通常是必须存在其中之一，它配置了Filter过滤的限定范围，且value,urlPatterns两个属性不能共存，一般我们是用urlPattern，忽略value属性</strong></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filterName</td>
<td>String</td>
<td>指定Servlet的name属性，等价于&lt;filter-name&gt;。</td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于urlPatterns属性。但是两者不应该同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组过滤器的URL匹配模式。等价于&lt;url-pattern&gt; 标签。</td>
</tr>
<tr>
<td>servletNames</td>
<td>String[]</td>
<td>指定过滤器将应用于哪些Servlet.取值是@WebServlet中的 name属性的取值，或者是web.xml中&lt;servlet-name&gt;的取值。</td>
</tr>
<tr>
<td>dispatcherTypes</td>
<td>DispatcherType</td>
<td>指定过滤器的转发模式，具体取值包括：ASYNC, ERROR, FORWARD, INCLUDE, REQUEST</td>
</tr>
<tr>
<td>initParams</td>
<td>WebInitParam[]</td>
<td>指定一组过滤器初始化参数，等价于&lt;init-param&gt; 标签。</td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明过滤器是否支持异步操作模式，等价于&lt;async-supported&gt;标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该过滤器的描述信息，等价于&lt;description&gt;标签。</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该过滤器的显示名，通常配合工具使用，等价于&lt;display-name&gt;标签。</td>
</tr>
</tbody>
</table>
<h2 id="Filter的执行顺序"><a href="#Filter的执行顺序" class="headerlink" title="Filter的执行顺序"></a>Filter的执行顺序</h2><p>如果定义了多个Filter,且一个请求同事会被多个Filter进行拦截，那么Filter的执行顺序根据web.xml中配置的Filter信息中<strong>&lt;filter-mapping&gt;</strong>的顺序从上到下执行</p>
<h2 id="Filter总结"><a href="#Filter总结" class="headerlink" title="Filter总结"></a>Filter总结</h2><p>Filter其实没有什么太多需要注意的地方，它和servlet非常相似，方法也大同小异。可以看成是servlet的变种,区别就是Filter不能直接对用户生成响应而</p>
<p>实际上Filter里的doFilter()方法里的代码就是从多个servlet的service()方法抽取的通用代码，通过使用filter可以实现更好的复用</p>
<p>利用Filetr我们可以用来做登录验证，关键字过滤，日志记录等模块的开发，但是现实常常使用Spring来进行开发，Spring有更加优秀的功能(Interceptor)来让我们进行处理，所以Filter的使用反而现在已经变少了,具体后面的spring笔记中会记录到</p>
<h1 id="Listener简介"><a href="#Listener简介" class="headerlink" title="Listener简介"></a>Listener简介</h1><p>Listener是Servlet的监听器，它可以监听客户端的请求，服务端的操作。 我们平常做开发的使用通常会给按钮增加监听器，点击这个按钮，触发一项监听事件，如Java swing开发中的ActionListener.</p>
<p>监听器Listener的内容就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>
<p>Listener是Servlet三大组件(Servlet,Filter,Listener)之一,是设计模式中<strong>观察者模式</strong>的体现</p>
<h2 id="Listener监听类型"><a href="#Listener监听类型" class="headerlink" title="Listener监听类型"></a>Listener监听类型</h2><p>Listener监听器分为三种监听类型</p>
<ul>
<li>对Session的操作， HttpSessionListener</li>
<li>对Request的操作， ServletReuqestListener</li>
<li>对context的操作， ServletContextListener</li>
</ul>
<p><img src="https://i.imgur.com/tuKnitQ.png" alt></p>
<p>创建Listener实例需要先创建Listener处理类，需要监控哪种类型就实现哪种类型的监听接口，由于JAVA接口可以多实现的特性，所以也可以将所有类型的监听都放在一个java类中，不过这样耦合性太高，不建议这样做</p>
<h2 id="Listener的监听对象及方法"><a href="#Listener的监听对象及方法" class="headerlink" title="Listener的监听对象及方法"></a>Listener的监听对象及方法</h2><table border="1px" cellspacing="0"><thead><tr><th>监听类型</th><th>监听内容与接口</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td rowspan="5" style="border-bottom-color:red ">request</td><td rowspan="2">生命周期:ServletContextRequest接口<br>用于监听用户请求</td><td>requestInitialized()</td><td>创建request时</td></tr><tr><td>requestDestroyed()</td><td>销毁request时</td></tr><tr><td rowspan="3" style="border-bottom-color:red ">属性: ServletRequestAttributeListener接口<br>用于监听ServletRequest范围（Request）内属性的改变</td><td>attributeAdded()</td><td>增加request属性时</td></tr><tr><td>attributeRemoved</td><td>移除request属性时</td></tr><tr><td style="border-bottom-color:red">attributeReplaced()</td><td style="border-bottom-color:red">修改request属性时</td></tr><tr><td rowspan="5" style="border-bottom-color:red ">session</td><td rowspan="2">生命周期:HttpSessionListener接口<br>用于监听用户Session的开始和结束</td><td>sessionCreated()</td><td>创建session时</td></tr><tr><td>sessionDestroyed()</td><td>销毁session时</td></tr><tr><td rowspan="3" style="border-bottom-color:red">属性:HttpSessionAttributeListener接口<br>用于监听HttpSession范围（Session）内属性的改变</td><td>attributeAdded()</td><td>增加session属性时</td></tr><tr><td>attributeRemoved()</td><td>移除session属性时</td></tr><tr><td style="border-bottom-color:red">attributeReplaced()</td><td style="border-bottom-color:red">修改session属性时</td></tr><tr><td rowspan="5">context</td><td rowspan="2">生命周期:ServletContextListener接口<br>用于监听Web应用的启动和关闭</td><td>contextInitialized(ServletContextEvent sce)</td><td>创建context时</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>销毁context时</td></tr><tr><td rowspan="3">属性:ServletContextAttributeListener接口<br>用于监听ServletContext范围（Application）内属性的改变</td><td>attributeAdded()</td><td>新增context属性</td></tr><tr><td>attributeRemoved()</td><td>移除context属性</td></tr><tr><td>attributeReplaced()</td><td>修改context属性</td></tr></tbody></table>

<h2 id="定义一个简单的Listener例子"><a href="#定义一个简单的Listener例子" class="headerlink" title="定义一个简单的Listener例子"></a>定义一个简单的Listener例子</h2><p>以MyServletContextListener为例</p>
<p>配置Listener类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyServletContextListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">		System.out.println(&quot;context was be created&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">		System.out.println(&quot;context was be destroy...&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>web.xml中配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;cn.hel.util.MyServletContextListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>关于Listener的配置， 在servlet3.0以上的版本中增加了注解配置，无需继续在web.xml中进行配置，直接在类上使用@WebListener注解即可，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class MyServletContextListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于@WebListener注解与web.xml中配置listener的属性对照：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>是否可选</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>是</td>
<td>该监听器的描述信息。</td>
</tr>
</tbody>
</table>
<h2 id="Listener的应用"><a href="#Listener的应用" class="headerlink" title="Listener的应用"></a>Listener的应用</h2><p>关于Servlet Listener的应用有很多，举几个常用的例子，如： 初始化整个网站所用的参数（ServletContextListener），日志记录，记录网站的在线人数等.</p>
<p>在Spring中，最常见的就是使用ContextLoaderListener来获取Spring运行相关的配置信息，如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>以及通过RequestContextListener扩展ServletRequestListener,用来配合DispatcherServlet的实现等.</p>
<h1 id="Servlet-Filter-Listener的初始化顺序"><a href="#Servlet-Filter-Listener的初始化顺序" class="headerlink" title="Servlet,Filter,Listener的初始化顺序"></a>Servlet,Filter,Listener的初始化顺序</h1><p>以上已经将Servlet三大组件（servlet,filter,listener）已经记录完了，他们对应的初始化方法分别为</p>
<ol>
<li>init(ServletConfig config)</li>
<li>init(FilterConfig filterConfig)</li>
<li>contextInitialized(ServletContextEvent arg0)</li>
</ol>
<p>使用之前的例子来进行测试，完整web.xml配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;cn.hel.util.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;loginFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;cn.hel.util.LoginFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;loginFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;cn.hel.util.MyServletContextListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>此处因为需要注意的是Servlet需要加<strong>&lt;load-on-startup&gt;</strong>进行测试，否则servlet只在请求到达时才会初始化，无法验证效果</p>
<p>输出结果：</p>
<p><img src="https://i.imgur.com/iV3BIKm.png" alt></p>
<p>他们三者的默认运行顺序为 Listener &gt; Filter &gt; Servlet，销毁顺序为： servlet &gt; filter &gt; listener 如果在web.xml中配置了&lt;context-param&gt;，则初始化顺序为<strong>context-param &gt; Listener &gt; Filter &gt; Servlet</strong></p>
<p>参考： </p>
<p><a href="https://blog.csdn.net/u012228718/article/details/41730799" target="_blank" rel="noopener">CSDN: Servlet学习笔记（九）：监听器Listener详解</a></p>
<p><a href="https://tianweili.github.io/2015/01/27/Java%E4%B8%AD%E7%9A%84Listener-%E7%9B%91%E5%90%AC%E5%99%A8/" target="_blank" rel="noopener">Java中的Listener 监听器</a></p>
<p><a href="http://zhxing.iteye.com/blog/399668" target="_blank" rel="noopener">Iteye: web.xml 中的listener、 filter、servlet 加载顺序及其详解</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java Web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb开发学习笔记之Servlet（三） Cookie与Session, 及Servlet线程安全问题</title>
    <url>/2018/11/21/Servlet(3)Cookie%E4%B8%8ESession,%20%E5%8F%8AServlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是服务器发送给浏览器的体积很小的纯文本信息，用户以后访问同一个Web服务器时浏览器会把它们原样发送给服务器。引用维基百科的解释：</p>
<blockquote>
<p>指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p>
</blockquote>
<p>cookie是识别当前用户，实现持久对话的最好方式，目前所有主流浏览器都支持，以至于Http协议都为其定义了新的Http头部。</p>
<h3 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h3><ul>
<li>cookie通过请求头/响应头在服务器与客户端之间传输，大小限制为4KB</li>
<li>一台服务器在一个客户端最多保存20个cookie</li>
<li>一个浏览器最多保存300个cookie</li>
<li>cookie的name和value都不能使用中文，如果需要使用中文，需要对中文进行URL编码,解码操作。</li>
</ul>
<h3 id="Cookie的应用"><a href="#Cookie的应用" class="headerlink" title="Cookie的应用"></a>Cookie的应用</h3><p>cookie一般有两个作用，识别用户身份和记录历史</p>
<ul>
<li>识别用户身份： 假设一个A用户访问了，a.com, 那么服务器就给这个用户A返回一个cookie,如[cookie=A], 当A再次访问时a.com时，请求中就会带上[cookie=A]这个cookie. 同理,用户B访问a.com时，服务器分配一个cookie,[cookie=B]给B用户，当B再次访问时，会在请求中带上[cookie=B]这个cookie。 这样，服务器就能够知道到底是A在访问还是B在访问了</li>
<li>记录历史，常见的如购物车功能。假设一个用户A进入一个购物网站，讲a商品，b商品添加到购物车，那么这个购物网站就会给这个用户A返回一个cookie, 如：<br>[cookie=A, cart=a,b],这样，当用户下次再进入这个网站时，会将这个cookie一并带入请求，就可以看到商品a，b依然躺在购物车里了。</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制。在一段时间内，一个客户与Web服务器的一系列交互过程，称为”会话”，也就是session， session是一个比较抽象的概念，</p>
<p>我们今天常说的session，是为了绕开cookie的各种限制，通常借住cookie本身和后端存储实现的，一种更高级的状态实现。session是由服务器端生成的，存储在服务器端。</p>
<p>我们可以对session设置过期时间，单位是<strong>分钟</strong>，在web.xml中配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt; </span><br><span class="line">	&lt;session-timeout&gt;30&lt;/session-timeout&gt; </span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是我们如果在代码中设置session的过期时间，单位是<strong>秒</strong>,如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session.setMaxInactiveInterval(int seconds)</span><br></pre></td></tr></table></figure></p>
<p>tomcat的默认session过期时间为30分钟<br><img src="https://i.imgur.com/dZeOGM3.png" alt></p>
<h3 id="Session与Cookie的比较说明"><a href="#Session与Cookie的比较说明" class="headerlink" title="Session与Cookie的比较说明"></a>Session与Cookie的比较说明</h3><ul>
<li>session在服务器端，cookie在客户端（浏览器）</li>
<li>session存储的数据量大，数据类型丰富。 cookie存储的数据量不超过4KB，且只能存储ASCII字符串。</li>
<li>根据以上第一点，安全性方面session优于cookie. cookie在客户端中是可见的。</li>
<li>跨域方面cookie优于session，cookie只要设置domain域更改即可。</li>
<li>对于服务器的压力，session的压力大大高于cookie</li>
<li>有效期的不同，只要关闭了浏览器session就会失效，不能完成信息永久保存，且如果session设置的超时过长，服务器累计的session就会越多，越容易招致内存溢出。</li>
</ul>
<p>通常我们的做法是将用户的登录信息，如账号密码保存在session中，在cookie保存此session的session id,请求时让保存的session id随着cookie一同访问，通过session id的机智来获取session进行验证即可。</p>
<h1 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h1><h2 id="Servlet的线程安全问题-1"><a href="#Servlet的线程安全问题-1" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h2><p>当Servlet容器接收到Client的Http请求时，容器会先从线程池中取出一个线程然后找到该请求对应的Servlet对象，并进行初始化（init), 再调用service()方法， 而当另一个客户端再次发出请求访问该servlet时，并不会再次初始化这个servlet,不会调用init，也就是说，多个线程在使用这一个servlet实例。<strong>JSP/Servlet容器默认采用的是单实例方式处理多个请求</strong>，这样设计的好处是减少产生Servlet实例的开销，提升了对请求的响应时间。对于Tomcat可以在server.xml中通过<connector>元素设置线程池中线程的数目。</connector></p>
<p>也正因为此，我们不能在Servlet中修改成员变量，否则会引发线程安全问题</p>
<h2 id="如何开发线程安全的Servlet"><a href="#如何开发线程安全的Servlet" class="headerlink" title="如何开发线程安全的Servlet"></a>如何开发线程安全的Servlet</h2><p>关于如何开发线程安全的Servlet，可以从以下几点入手：</p>
<ul>
<li>变量：<br>将参数变量本地化，使用局部变量而不是成员变量。</li>
<li>属性： ServletContext,HttpSession,ServletRequest对象中的属性.<br>其中,ServletContext和HttpSession是线程不安全的，因为这两个对象可以同时被多个servlet对象共享。ServletRequest对象是线程安全的，对于每一个请求都会创建一个新的ServletRequest对象，所以ServletRequest对象只能在一个线程中被访问，它是线程安全的。</li>
<li>使用同步快Synchronized,防止可能异步调用的代码块。为多线程增加排队</li>
<li>使用同步的集合类，使用Vector代替ArrayList,使用HashTable代替HashMap。</li>
<li>不要再Servlet中创建自己的线程来完成某个功能</li>
<li>在多个Servlet中对外部对象（如文件）进行修改操作一定要加锁，做到互斥的访问</li>
<li>实现ServletThreadModel接口<br>javax.servlet.SingleThreadModel接口是一个标识接口，如果一个Servlet实现了这个接口，那Servlet容器将保证在一个时刻仅有一个线程可以在给定的servlet实例的service方法中执行。将其他所有请求进行排队。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class xxx extends HttpServlet implements SingleThreadModel&#123;</span><br><span class="line">	// 这种方法会产生大量系统开销，尽量不要用。SingleThreadModel已废弃</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用了SingleThreadModel接口，服务器可以使用多个实例来处理请求，代替单个实例的请求排队带来的效益问题。服务器创建一个Servlet类的多个Servlet实例组成的实例池，对于每个请求分配Servlet实例进行响应处理，之后放回到实例池中等待下此请求。这样就造成并发访问的问题。 此时,局部变量(字段)也是安全的，但对于全局变量和共享数据是不安全的，需要进行同步处理。而对于这样多实例的情况SingleThreadModel接口并不能解决并发访问问题。<strong>SingleThreadModel接口在servlet规范中已经被废弃了</strong>。</p>
<p>参考与引用：</p>
<p><a href="https://zhuanlan.zhihu.com/p/22396872" target="_blank" rel="noopener">知乎：cookie是什么</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27669892" target="_blank" rel="noopener">知乎：认识HTTP—-Cookie和Session篇</a></p>
<p><a href="http://www.cnblogs.com/binyue/p/4513577.html#undefined" target="_blank" rel="noopener">博客园：Servlet的多线程和线程安全</a></p>
<p><a href="https://www.zhihu.com/question/23219109" target="_blank" rel="noopener">知乎：Servlet与多线程的关系是什么</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java Web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb开发学习笔记之Servlet（二） Servlet生命周期与配置信息</title>
    <url>/2018/11/19/Servlet(2)Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="创建Servlet对象的过程"><a href="#创建Servlet对象的过程" class="headerlink" title="创建Servlet对象的过程"></a>创建Servlet对象的过程</h1><ul>
<li>当Servlet容器启动时，会首先读取web.xml配置文件的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。</li>
<li>在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。</li>
<li>Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的<strong>&lt;load-on-startup&gt;</strong>属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。web.xml配置如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;Init&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.xl.servlet.InitServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于<strong>&lt;load-on-startup&gt;</strong>的含义是， 标记容器是否在启动的时候就加载这个servlet； 当是一个负数或者未指定时，则指示容器在该servlet被选择时才加载。 正数的值越小，启动该servlet的优先级越高</li>
</ul>
<h1 id="如何创建配置Servlet"><a href="#如何创建配置Servlet" class="headerlink" title="如何创建配置Servlet"></a>如何创建配置Servlet</h1><p>关于Servlet的创建于使用我们需要两个实现要步</p>
<ol>
<li>创建一个java类，继承HttpServlet类。 当然，根据JAVA的类继承顺序，我们也可以对HttpServlet的父类进行操作，但是继承HttpServlet类是最常见的，因为HttpServlet类帮我们内部实现了一部分方法，无需我们手动再进行实现</li>
<li>配置web.xml文件</li>
</ol>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;init....&quot;);</span><br><span class="line">		 // Servlet初始化</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;进入Service方法&quot;);</span><br><span class="line">		// 实际进行业务逻辑处理的地方</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;destroy....&quot;);</span><br><span class="line">		 // Servlet销毁</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在web.xml配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;cn.hel.util.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">// &lt;servlet&gt;用于注册Servlet，包含了&lt;servlet-name&gt;和&lt;servlet-class&gt;两个子元素，分别用于设置servlet的名称以及servlet的类名。</span><br><span class="line">// &lt;servlet-mapping&gt;用于映射上面&lt;servlet&gt;中的对外访问路径，同样包含&lt;servlet-name&gt;和&lt;url-pattern&gt;两个元素，分别用于设置servlet的名称以及servlet的对外访问路径。</span><br></pre></td></tr></table></figure></p>
<p>测试启动与发送请求，输出：</p>
<p><img src="https://i.imgur.com/BgE68ab.png" alt></p>
<h1 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h1><p>关于Servlet的生命周期，在上面的例子中其实也可以看到。servlet的声明周期主要围绕三个方法进行，init(), service(), destroy(), 关于这三个方法的说明如下。</p>
<ul>
<li>init()，Servlet初始化时调用，只执行一次</li>
<li>service(), 直接处理业务逻辑请求的方法</li>
<li>destroy(), Servlet生命周期结束时调用，进行销毁。只执行一次</li>
</ul>
<h1 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h1><p>ServletConfig主要用于加载Servlet的初始化参数,在一个web应用可以存在多个ServletConfig对象。</p>
<p><img src="https://i.imgur.com/JnZTdcW.png" alt></p>
<p>ServletConfig主要包含四个方法</p>
<ul>
<li>String getServletName()  – 获取当前Servlet在web.xml中配置的名字</li>
<li>String getInitParameter(String name) – 获取当前Servlet指定名称的初始化参数的值</li>
<li>Enumeration getInitParameterNames()  – 获取当前Servlet所有初始化参数的名字组成的枚举</li>
<li>ServletContext getServletContext()  – 获取代表当前web应用的ServletContext对象</li>
</ul>
<h2 id="ServletConfig获取基本配置信息"><a href="#ServletConfig获取基本配置信息" class="headerlink" title="ServletConfig获取基本配置信息"></a>ServletConfig获取基本配置信息</h2><p>在Servlet的配置文件中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。（配置在某个 servlet标签）当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数 封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet,因此通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</init-param></p>
<p><strong>ServletConfig代表的是Servlet在web.xml中的配置信息,对应web.xml中的Servlet元素</strong></p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;cn.hel.util.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">	&lt;!--配置HelloServlet的初始化参数 --&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;name&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;gacl&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;password&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;123&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;charset&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>在HttpServlet中获取.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;======进入Service方法========&quot;);</span><br><span class="line">		</span><br><span class="line">		ServletConfig config = this.getServletConfig();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;ServletName: &quot;+config.getServletName());</span><br><span class="line">		//获取在web.xml中配置的初始化参数</span><br><span class="line">        String paramVal = config.getInitParameter(&quot;name&quot;);//获取指定的初始化参数</span><br><span class="line">        System.out.println(paramVal);</span><br><span class="line">        </span><br><span class="line">        //获取所有的初始化参数</span><br><span class="line">        Enumeration&lt;String&gt; e = config.getInitParameterNames();</span><br><span class="line">        while(e.hasMoreElements())&#123;</span><br><span class="line">            String name = e.nextElement();</span><br><span class="line">            String value = config.getInitParameter(name);</span><br><span class="line">            System.out.println(name + &quot;=&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;destroy....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<p><img src="https://i.imgur.com/i9D4LGW.png" alt></p>
<p>我们如果是用IDE工具进行调试的话（此处我用的是Eclipse+Tomcat），其实可以看到我们获取的ServletConfig对象，本身都是一个<a href="https://tomcat.apache.org/tomcat-6.0-doc/api/org/apache/catalina/core/StandardWrapperFacade.html" target="_blank" rel="noopener">org.apache.catalina.core.StandardWrapperFacade</a>类对象，来源于Tomcat容器。针对这一点，在以后tomcat的笔记中再进行详细研究。</p>
<p>关于Servlet的配置， 在servlet3.0以上的版本中增加了注解配置，无需继续在web.xml中进行配置，直接在类上使用@WebServlet注解即可，例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebServlet(name = &quot;hello&quot;, urlPatterns = &#123; &quot;/hello&quot;, &quot;/hello/*&quot; &#125;, loadOnStartup = 1, initParams = &#123;</span><br><span class="line">		@WebInitParam(name = &quot;name&quot;, value = &quot;gacl&quot;), @WebInitParam(name = &quot;password&quot;, value = &quot;123&quot;),</span><br><span class="line">		@WebInitParam(name = &quot;charset&quot;, value = &quot;UTF-8&quot;) &#125;)</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于@WebServlet注解与web.xml中配置servlet的属性对照，<strong>@WebServlet注解的属性都为可选属性，但是value或者urlPatterns通常是必须存在其中之一，它配置了servlet请求的限定范围，且两个属性不能共存，一般我们是用urlPattern，忽略value属性</strong>。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td>指定Servlet的name属性，等价于&lt;servlet-name&gt;。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。</td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性。两个属性不能同时使用。</td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组Servlet的URL匹配模式。等价于&lt;url-pattern&gt;标签。</td>
</tr>
<tr>
<td>loadOnStartup</td>
<td>int</td>
<td>指定Servlet的加载顺序，等价于&lt;load-on-startup&gt;标签。</td>
</tr>
<tr>
<td>initParams</td>
<td>WebInitParam[]</td>
<td>指定一组Servlet初始化参数，等价于&lt;init-param&gt;标签。</td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明Servlet是否支持异步操作模式，等价于&lt;async-supported&gt;标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该Servlet的描述信息，等价于&lt;description&gt;标签。</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该Servlet的显示名，通常配合工具使用，等价于&lt;display-name&gt;标签。</td>
</tr>
</tbody>
</table>
<p>关于initParams的值，它是一个WebInitParam数组，数组中的每一个值由一个@WebInitParam注解进行配置，关于@WebInitParam注解，不光配合@WebServlet中可以使用，在配置过滤器使用@Filter时也可以使用，以下是@WebInitParam的参数说明</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>是否可选</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td>否</td>
<td>指定参数的名字，等价于&lt;param-name&gt;。</td>
</tr>
<tr>
<td>value</td>
<td>String</td>
<td>否</td>
<td>指定参数的值，等价于&lt;param-value&gt;。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>是</td>
<td>关于参数的描述，等价于&lt;description&gt;。</td>
</tr>
</tbody>
</table>
<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a><div style="color:#f55302">ServletContext对象</div></h2><h3 id="ServletContext对象的定义"><a href="#ServletContext对象的定义" class="headerlink" title="ServletContext对象的定义"></a>ServletContext对象的定义</h3><p><strong>ServletContext代表的是当前的web应用，是Servlet容器上下文环境对象。</strong>定义一组方法，servlet使用这些方法与其servlet容器进行通信。例如，获取文件的 MIME 类型、分发请求或写入日志文件。每个web应用都有且仅有一个ServletContext对象，这个对象在所有的Servlet都可以使用。</p>
<p>以下为ServletContext源码中对其的定义说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Defines a set of methods that a servlet uses to communicate with its</span><br><span class="line"> * servlet container, for example, to get the MIME type of a file, dispatch</span><br><span class="line"> * requests, or write to a log file.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;There is one context per &quot;web application&quot; per Java Virtual Machine.  (A</span><br><span class="line"> * &quot;web application&quot; is a collection of servlets and content installed under a</span><br><span class="line"> * specific subset of the server&apos;s URL namespace such as &lt;code&gt;/catalog&lt;/code&gt;</span><br><span class="line"> * and possibly installed via a &lt;code&gt;.war&lt;/code&gt; file.) </span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In the case of a web</span><br><span class="line"> * application marked &quot;distributed&quot; in its deployment descriptor, there will</span><br><span class="line"> * be one context instance for each virtual machine.  In this situation, the </span><br><span class="line"> * context cannot be used as a location to share global information (because</span><br><span class="line"> * the information won&apos;t be truly global).  Use an external resource like </span><br><span class="line"> * a database instead.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The &lt;code&gt;ServletContext&lt;/code&gt; object is contained within </span><br><span class="line"> * the &#123;@link ServletConfig&#125; object, which the Web server provides the</span><br><span class="line"> * servlet when the servlet is initialized.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="ServletContext对象的获取方式"><a href="#ServletContext对象的获取方式" class="headerlink" title="ServletContext对象的获取方式"></a>ServletContext对象的获取方式</h3><p>在Servlet中获取ServletContext对象可通过以下三种方式获得</p>
<ul>
<li>this.getServletContext();</li>
<li>this.getServletConfig().getServletContext();</li>
<li>request.getSession().getServletContext();</li>
</ul>
<p>三种方式获取的ServletContext对象都为同一个。</p>
<h3 id="ServletContext的作用"><a href="#ServletContext的作用" class="headerlink" title="ServletContext的作用"></a>ServletContext的作用</h3><p>web容器启动时，它为每一个web程序都创建一个对应的ServletContext对象，它代表着当前的web应用，事实上SpringMVC封装的ApplicationContext及Struts2封装的ApplicationContext里面都保存着原本的ServletContext.</p>
<p>ServletConfig获取的是配置在web.xml中的信息，ServletContext可以获取外部资源信息，如常用的properties文件信息。</p>
<p><strong>ServletContext配置的参数，可以被同一web应用下的所有servlet共享</strong>， 也正因此，Servlet对象之间可以通过ServletContext对象进行通讯，ServletContext通常也被称为域对象。</p>
<p>总结ServletContext的作用： Web应用范围内存共享数据；访问web应用的静态资源； Servlet对应之间通过ServletContext对象实现通讯。</p>
<p>例，获取web.xml中配置的上下文初始化参数：</p>
<p>在web.xml配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置context --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;username&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;zhangsan&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></p>
<p>在servlet中获取<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line">context.getInitParameter(&quot;username&quot;)</span><br><span class="line">// ServletContext中的getInitParameter()和getInitParameterNames()方法与ServletConfig中的用法一致</span><br></pre></td></tr></table></figure></p>
<p>例，获取ServletContext的上下文属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext context =this.getServletContext();</span><br><span class="line">context.setAttribute(&quot;name&quot;,&quot;value&quot;);</span><br><span class="line">context.getAttribute(&quot;name&quot;);</span><br><span class="line"> </span><br><span class="line">Enumberation p=application.getAttributeNames();</span><br></pre></td></tr></table></figure></p>
<h3 id="ServletContext的主要方法"><a href="#ServletContext的主要方法" class="headerlink" title="ServletContext的主要方法"></a>ServletContext的主要方法</h3><ol>
<li>属性相关，web应用范围内存共享数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setAttribute(String name,Object obj): 添加属性</span><br><span class="line">getAttribute(String name): 获取属性，返回Object</span><br><span class="line">removeAttribute(name): 删除属性： </span><br><span class="line">getAttributeNames(), 获取所有属性</span><br></pre></td></tr></table></figure>
<ol>
<li>加载资源文件，访问静态资源</li>
</ol>
<p>getResource(String parh): 获取代表某个资源的url对象，其中，path必须是/开头，代表当前web应用程序的根目录</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL url = context.getResource(&quot;/WEB-INF/classes/jdbc.properties&quot;);//得到URL              </span><br><span class="line">InputStream in_url = url.openStream();//直接得到流  </span><br><span class="line">Properties props1 = new Properties(); </span><br><span class="line">props1.load(in_url);//获取资源文件</span><br></pre></td></tr></table></figure>
</code></pre><p>getResoutceAsStream(String parh)，返回文件流。这个好处是可以使用相对于根目录的路径访问到web目录下的所有文件，而不必知道绝对路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream in = context.getResourceAsStream(&quot;/WEB-INF/classes/jdbc.properties&quot;);  </span><br><span class="line">Properties props = new Properties(); </span><br><span class="line">props.load(in);</span><br></pre></td></tr></table></figure></p>
<h2 id="请求转发与重定向"><a href="#请求转发与重定向" class="headerlink" title="请求转发与重定向"></a>请求转发与重定向</h2><p>请求转发能实现的主要原因是由于ServletContext的数据共享。</p>
<p>关于请求转发与重定向的模式说明，举例，一个人去银行办事，如果柜台的员工无法处理，她叫你等在这里，去叫经理过来处理，那么这就是请求转发， 重定向是，一个人去银行办事，如果柜台的员工无法处理，她说这个业务我们这个网点办理不了，建议去其他网点办理，然后你就去了另外一个网点办理业务，这就是重定向。</p>
<p>请求转发与重定向的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">请求转发</th>
<th style="text-align:center">重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">浏览器URL</td>
<td style="text-align:center">原来的url</td>
<td style="text-align:center">新的url</td>
</tr>
<tr>
<td style="text-align:center">请求次数</td>
<td style="text-align:center">1次</td>
<td style="text-align:center">2次</td>
</tr>
<tr>
<td style="text-align:center">跳转范围</td>
<td style="text-align:center">只能请求项目中的资源</td>
<td style="text-align:center">可以跳转到项目外</td>
</tr>
<tr>
<td style="text-align:center">转发</td>
<td style="text-align:center">只能请求项目中的资源</td>
<td style="text-align:center">可以跳转到项目外</td>
</tr>
</tbody>
</table>
<p>请求转发的实现方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RequestDispatcher rd = this.getServletContext().getRequestDispatcher(urlPath);</span><br><span class="line">rd.forward(request, response);</span><br></pre></td></tr></table></figure></p>
<p>重定向<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(urlPath);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用ServletContext动态配置"><a href="#使用ServletContext动态配置" class="headerlink" title="使用ServletContext动态配置"></a>使用ServletContext动态配置</h2><p>在servlet3.0以后的版本中对于ServletContext的性能进行了增强，该对象支持在运行时动态部署Servlet，Filter，Listener,以及为Servlet和Filter增加url映射。</p>
<p>此处我们以Servlet为例，Filter与Listener的与其大同小异。</p>
<p>之前我们说到配置一个servlet有两种方式</p>
<ol>
<li>在web.xml中配置映射</li>
<li>为servlet对象增加@WebServlet注解配置映射</li>
</ol>
<p>在3.0以后的servlet版本中，ServeltContext类中对于Servlet增加了以下几个方法。</p>
<ul>
<li>ServletRegistration.Dynamic addServlet(String servletName, String className);</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, String className)</li>
<li><t extends servlet> T createServlet(Class<t> clazz)</t></t></li>
<li>ServletRegistration getServletRegistration(String servletName)</li>
<li>Map&lt;String,? extends ServletRegistration&gt; getServletRegistrations()、</li>
</ul>
<p>关于以上几个方法，前三个重载方法为添加serlvet到注册中心，createServlet动态创建一个servlet, 后两个为获取注册中心ServletRegistration。</p>
<p>ServletRegistration，这个类提供动态注册，像SpringBoot就是通过动态注册servlet到容器。</p>
<p>使用context动态注册新的servlet，是在context初始化时调用。即，在ServletContextListener的contexInitialized()方法中， 或者是在ServletContainerInitializer类中的onStartup()方法中被调用。ServletContainerInitializer是servlet3.0后新增的一个接口</p>
<p>例：</p>
<p>新建一个Servlet类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicCreateTestServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;DynamicCreateTestServlet service ......&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在context初始化时动态注册一个新的Servlet<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class MyServletContextListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">		System.out.println(&quot;listener init... &quot;);</span><br><span class="line">		</span><br><span class="line">		// 在Listener监听器中获取ServletContext</span><br><span class="line">		ServletContext context = sce.getServletContext();</span><br><span class="line">		HttpServlet servlet;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 创建一个Servlet</span><br><span class="line">			servlet = context.createServlet(DynamicCreateTestServlet.class);</span><br><span class="line">			// 将创建的Servlet添加到注册中心,键为servlet-name, 值为新建的servlet类</span><br><span class="line">			context.addServlet(&quot;testServlet&quot;, servlet);</span><br><span class="line">			// 根据新建的servlet,通过其servlet-name获取对应的注册中心</span><br><span class="line">			ServletRegistration registration = context.getServletRegistration(&quot;testServlet&quot;);</span><br><span class="line">			// 为注册中心增加映射,相当于为新建的servlet增加urlPattern, 值为一个动态String数组</span><br><span class="line">			registration.addMapping(&quot;/dynimcServlet&quot;);</span><br><span class="line">		&#125; catch (ServletException e) &#123;</span><br><span class="line">			System.out.println(&quot;dynamic add servlet fail&quot;);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">		System.out.println(&quot;listener destroy...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里还有一点，获取注册中心ServletRegistration时除了使用getServletRegistration()方法<br>精确获取某一个ServletRegistration之外<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletRegistration getServletRegistration(String servletName)</span><br></pre></td></tr></table></figure></p>
<p>也可以使用getServletRegistrations()获取所有注册注册中心<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String,? extends ServletRegistration&gt; getServletRegistrations()</span><br></pre></td></tr></table></figure></p>
<p>而我们获取的这个Map打印时，除了我们自己配置的Servlet，还有两个不是我们配置的Servlet， 它们的servlet-name一个叫default,一个叫jsp，这两者来源于我使用的tomcat容器，在后面tomcat的内容中会进行讲述。</p>
<p>参考与引用：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html" target="_blank" rel="noopener">IBM developerWorks: Servlet3.0新特性详解——张建平</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java Web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb开发学习笔记之Servlet（一） Servlet与Servlet容器的概念</title>
    <url>/2018/11/12/Servlet(1)%20Servlet%E4%B8%8EServlet%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Servlet的定义"><a href="#Servlet的定义" class="headerlink" title="Servlet的定义"></a>Servlet的定义</h1><blockquote>
<p>Servlet是一种Java编写的后台服务程序, 主要功能是交互式地浏览和修改数据，生成动态Web内容，可以理解为http请求与数据库或其他程序之间的中间层。</p>
</blockquote>
<p>要说清楚什么是Servlet还是得从Servlet容器开始说起。</p>
<h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><p>Servlet容器（Servlet Container），也可以称为Servlet引擎。是web服务器或应用服务器的一部分。</p>
<p><strong>Servlet本身是不能独立运行的，必须部署到Servlet容器中运行。</strong></p>
<p>由Servlet容器实例化和调用servlet方法，Servlet容器在Servlet生命周期内包含和管理servlet。常见的servlet容器有tomcat, JBoss, Jetty, Web logic等。</p>
<p>我们平常的Servlet开发过程中,接收请求这项工作并不是直接由Servlet来工作的,Servlet并不直接与客户端打交道。真正负责这项工作的是servlet容器。<strong>接收请求,监听端口这些工作都是由servlet容器来操作完成的。</strong></p>
<p>随便谷歌一个servlet的hello world教程，里面都会让你写一个servlet，但是从来不会在servlet中写什么监听8080端口的代码，servlet不会直接和客户端打交道！。</p>
<p><strong>tomcat等Servlet容器才是与客户端直接打交道的家伙</strong>，它监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端。</p>
<p>说起来，Servlet与Servlet容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。</p>
<h2 id="Servlet的本质是一个接口"><a href="#Servlet的本质是一个接口" class="headerlink" title="Servlet的本质是一个接口"></a>Servlet的本质是一个接口</h2><p>其实不用把Servlet想象成一个非常复杂的东西，事实上,<strong>Servlet的本质就是一个接口</strong>, 接口是用来干嘛的，定义规范！所以我们也可以说，<strong>Servlet的本质是一规范</strong>， 甚至我们还可以说,J2EE的本质就是一种规范。</p>
<h2 id="Servlet类结构图"><a href="#Servlet类结构图" class="headerlink" title="Servlet类结构图"></a>Servlet类结构图</h2><p><img src="https://i.imgur.com/Ogg7uwJ.png" alt></p>
<p>以上图片来源Google</p>
<p>Servlet最顶层的就是一个Servlet接口，它里面定义了5个方法</p>
<p><img src="https://i.imgur.com/A94949P.png" alt></p>
<p>servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法 init()和destroy()，还有一个处理请求的service()，也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：</p>
<ul>
<li>你初始化时要做什么</li>
<li>你销毁时要做什么</li>
<li>你接受到请求时要做什么</li>
</ul>
<p>这就是Java给的一种规范，就像阿西莫夫的机器人三大定律、行尸走肉里Rick的那三个问题一样，规范！</p>
<h1 id="Servlet的工作原理图"><a href="#Servlet的工作原理图" class="headerlink" title="Servlet的工作原理图"></a>Servlet的工作原理图</h1><p>图一</p>
<p><img src="https://i.imgur.com/Tv3WMru.jpg" alt></p>
<p>图二</p>
<p><img src="https://i.imgur.com/YXZzV5a.jpg" alt></p>
<h1 id="Servlet的工作模式"><a href="#Servlet的工作模式" class="headerlink" title="Servlet的工作模式"></a>Servlet的工作模式</h1><ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<p>以上。</p>
<p>参考与引用： </p>
<p><a href="https://www.zhihu.com/question/21416727/answer/339012081" target="_blank" rel="noopener">知乎：servlet的本质是什么，它是如何工作的</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html" target="_blank" rel="noopener">IBM developerWorks: Servlet工作原理解析——许令波</a></p>
<p><a href="http://www.51gjie.com/javaweb/846.html" target="_blank" rel="noopener">JavaSchool Servlet教程</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java Web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Java获取JDBC元数据对象</title>
    <url>/2018/09/21/JDBC%E8%8E%B7%E5%8F%96%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天遇到一个问题，有一个需求，需要先判断数据库表是否存在，不存在则创建。按照我的第一思路，写一个SQL语句查询数据库表是否存在，不存在就创建好了</p>
<p>如以下的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SHOW TABLES： 显示当前数据库中所有表的名称</span><br><span class="line">// SHOW TABLES FROM database_name; // 查询xx数据库下所有表名</span><br><span class="line">SHOW TABLES LIKE &apos;tablename&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查询数据库所有表名： </span><br><span class="line">SELECT * FROM information_schema.tables WHERE table_schema =&apos;database_name&apos; AND table_name = &apos;tablename&apos;;</span><br></pre></td></tr></table></figure></p>
<p>然后发现了一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">DatabaseMetaData databaseMetaData = conn.getMetaData();</span><br><span class="line">ResultSet resultSet = databaseMetaData.getTables(null, null, &quot;tablename&quot;, null);</span><br><span class="line">if (resultSet.next()) &#123;</span><br><span class="line">	System.out.println(&quot;table exist!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	System.out.println(&quot;table not exist&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不使用SQL就可以查询到，那不是更方便吗。于是我就去了解了一下DatabaseMetaData这个类。</p>
<h1 id="DatabaseMetaData接口获取JDBC元数据"><a href="#DatabaseMetaData接口获取JDBC元数据" class="headerlink" title="DatabaseMetaData接口获取JDBC元数据"></a>DatabaseMetaData接口获取JDBC元数据</h1><h2 id="什么是元数据"><a href="#什么是元数据" class="headerlink" title="什么是元数据"></a>什么是元数据</h2><p>是描述存储在数据源中的数据的数据，是关于数据的数据，其中有两种类型的数据，关于<strong>数据结构的设计和规范的结构元数据</strong>以及<strong>关于资源和自身实例信息的识别的描述性元数据</strong></p>
<p>元数据通常包括数据库中每个表的名称，大小和行数，以及每个表中的列，它们的数据类型，精度等。考虑到这一点，让我们从教程开始，了解如何从任何数据源获取元数据。</p>
<h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><p>首先， 获取DatabaseMetaData的方法其实在上面的方法中已经给出了，一行代码即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DatabaseMetaData databaseMetaData = conn.getMetaData();</span><br></pre></td></tr></table></figure></p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getTables()     	// 得到指定参数的表信息参数说明 </span><br><span class="line">getColumns() 	 	// 得到指定表的列信息</span><br><span class="line">getPrimaryKeys() 	// 获取表的主键信息</span><br><span class="line">getExportedKeys()   // 获取表的外键信息</span><br><span class="line">getTypeInfo()    	// 获取此数据库支持的所有数据类型的描述</span><br><span class="line">// 参数说明：</span><br><span class="line">catalog： 类别名称，一般为空</span><br><span class="line">   schema ： 数据库名</span><br><span class="line">   tableName ：表名</span><br><span class="line">columnName ：列名</span><br></pre></td></tr></table></figure>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DatabaseMetaData databaseMetaData = conn.getMetaData();</span><br><span class="line">System.out.println(&quot;数据库已知的用户: &quot; + databaseMetaData.getUserName());</span><br><span class="line">System.out.println(&quot;数据库URL: &quot; + databaseMetaData.getURL());</span><br><span class="line">System.out.println(&quot;是否允许只读:&quot; + databaseMetaData.isReadOnly());</span><br><span class="line">System.out.println(&quot;数据库的产品名称:&quot; + databaseMetaData.getDatabaseProductName());</span><br><span class="line">System.out.println(&quot;数据库的版本:&quot; + databaseMetaData.getDatabaseProductVersion());</span><br><span class="line">System.out.println(&quot;驱动程序的名称:&quot; + databaseMetaData.getDriverName());</span><br><span class="line">System.out.println(&quot;驱动程序的版本:&quot; + databaseMetaData.getDriverVersion());</span><br><span class="line">System.out.println(&quot;数据库的系统函数的逗号分隔列表: &quot; + databaseMetaData.getSystemFunctions());</span><br><span class="line">System.out.println(&quot;数据库的时间和日期函数的逗号分隔列表: &quot; + databaseMetaData.getTimeDateFunctions());</span><br><span class="line">System.out.println(&quot;数据库的字符串函数的逗号分隔列表: &quot; + databaseMetaData.getStringFunctions());</span><br><span class="line">System.out.println(&quot;数据库供应商用于 &apos;schema&apos; 的首选术语: &quot; + databaseMetaData.getSchemaTerm());</span><br></pre></td></tr></table></figure></p>
<p>显示：</p>
<p><img src="https://i.imgur.com/A3XnH5i.png" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于这个接口，我在开发过程中并没有真正用到过。不过这个接口的强大是毋庸置疑的，很多数据都可以通过其获取。但是据说对于JDBC元数据的操作非常消耗性能，应尽量避免使用。当然咯，具体的事情具体再看吧</p>
<p>参考：</p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html" target="_blank" rel="noopener">Interface DatabaseMetaData</a></p>
<p><a href="https://www.progress.com/blogs/jdbc-tutorial-extracting-database-metadata-via-jdbc-driver" target="_blank" rel="noopener">JDBC Tutorial: Extracting Database Metadata via JDBC Driver</a></p>
<p><a href="https://examples.javacodegeeks.com/core-java/sql/jdbc-databasemetadata-example/" target="_blank" rel="noopener">JDBC DatabaseMetaData Example</a></p>
<p><a href="https://blog.csdn.net/chen_zw/article/details/18816599" target="_blank" rel="noopener">JDBC元数据操作（一）– DatabaseMetaData接口详解</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDBC</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>swing中添加右键菜单</title>
    <url>/2018/09/15/swing%E5%8F%B3%E9%94%AE%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>右键菜单是一直是一个非常实用的功能,在此，乘着现在还有一些印象做基础,存一个在swing中添加右键菜单功能的小例子，方便以后备用。</p>
<p>ps： 连Oracle官方都不推荐实用swing,而改用JavaFX了,基本上在官方的各种swing组件说明中都能看到一句</p>
<blockquote>
<p>If you are interested in using JavaFX to create your GUI, see <a href="https://docs.oracle.com/javase/8/javafx/layout-tutorial/index.html" target="_blank" rel="noopener">Working With Layouts in JavaFX</a>.</p>
</blockquote>
<pre><code>import java.awt.Color;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.WindowConstants;

public class Test02 {

    @SuppressWarnings(&quot;serial&quot;)
    class TextAreaMenu extends JTextArea{
        // 菜单增加选项,复制,粘贴,剪切
        JMenuItem copy = null, paste = null, cut = null; 

        public TextAreaMenu(){
            // 给当前组件添加右键菜单组件
            JPopupMenu menu = new JPopupMenu();
            menu.add(copy = new JMenuItem(&quot;复制&quot;));
            menu.add(paste = new JMenuItem(&quot;粘贴&quot;));
            menu.add(cut = new JMenuItem(&quot;剪切&quot;));

            // 设置键盘操作
            copy.setAccelerator(KeyStroke.getKeyStroke(&apos;C&apos;, InputEvent.CTRL_MASK));
            paste.setAccelerator(KeyStroke.getKeyStroke(&apos;V&apos;, InputEvent.CTRL_MASK));
            cut.setAccelerator(KeyStroke.getKeyStroke(&apos;X&apos;, InputEvent.CTRL_MASK));

            // 设置边框增强显示效果
            this.setBorder(BorderFactory.createLineBorder(Color.red));

            this.addMouseListener(new MouseAdapter(){
                // 当前组件的鼠标点击事件
                @Override
                public void mouseClicked(MouseEvent e) {
                    // MouseEvent.BUTTON1:  左键点击
                    // MouseEvent.BUTTON2:  中间点击(滑轮)
                    if(e.getButton() == MouseEvent.BUTTON3){
                        // 设置右键点击事件,打开邮件菜单
                        menu.show(TextAreaMenu.this,e.getX(),e.getY());

                        // 设置选项是否可用
                        boolean isCanCopy = isCanCopy();
                        copy.setEnabled(isCanCopy);
                        cut.setEnabled(isCanCopy);
                        // 剪贴板是否存在数据
                        paste.setEnabled(isClipboardString());
                    }
                }
            });

            // 初始化选项事件
            initEvent();
        }

        private void initEvent(){
            copy.addActionListener(new ActionListener(){
                @Override
                public void actionPerformed(ActionEvent e) {
                    System.out.println(&quot;点击了复制按钮&quot;);
                    TextAreaMenu.this.copy();
                }
            });

            paste.addActionListener(new ActionListener(){
                @Override
                public void actionPerformed(ActionEvent e) {
                    System.out.println(&quot;点击了粘贴按钮&quot;);
                    TextAreaMenu.this.paste();
                }
            });

            cut.addActionListener(new ActionListener(){
                @Override
                public void actionPerformed(ActionEvent e) {
                    System.out.println(&quot;点击了剪切按钮&quot;);
                    TextAreaMenu.this.cut();
                }
            });
        }

        /**
         * 当前文本组件是否可以复制
         * true 具备
         * false 不具备
         * @return 
         */
        public boolean isCanCopy() {
            // getSelectionStart() 返回选定文本的起始位置。如果是空文档，则返回 0；如果没有选定，则返回点值。
            int start = this.getSelectionStart();
            // getSelectionEnd() 返回选定文本的结束位置。如果文本为空，则返回 0；如果没有选择，则返回点值。
            int end = this.getSelectionEnd();
            return start != end;
        }

        /**
         * 剪切板中是否有文本数据可供粘贴
         * true 有文本数据
         * false 无
         * @return true为有文本数据
         */
        public boolean isClipboardString() {
            boolean b = false;
            // 获取剪贴板对象
            Clipboard clipboard = this.getToolkit().getSystemClipboard();
            try {
                // getContents(), 获取剪贴板对象中的数据对象,无则返回null
                Transferable content = clipboard.getContents(this);
                // getTransferData(), 获取数据对象中的值
                if (content.getTransferData(DataFlavor.stringFlavor) instanceof String) {
                    b = true;
                }
            } catch (Exception e) {
                return false;
            }
            return b;
        }
    }

    public static void main(String[] args) {
        JFrame jf = new JFrame(&quot;测试窗口&quot;);
        jf.setSize(600, 600);
        TextAreaMenu textAreaMenu = new Test02().new TextAreaMenu();
        jf.setContentPane(textAreaMenu);
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        jf.setVisible(true);
    }
}
</code></pre><p>显示:</p>
<p><img src="https://i.imgur.com/bL7tnjp.png" alt></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>Java图形化</category>
        <category>Swing</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SWING</tag>
      </tags>
  </entry>
  <entry>
    <title>Swing布局</title>
    <url>/2018/09/13/swing%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>swing是Java中的一个gui库。现在已经很少看到有使用swing开发的项目了.我也一直没有真正的使用swing进行开发,只是在刚接触java时根据例子简单敲了一下。不过最近,公司正好有一个项目是以swing为基础进行二次开发的,作为一个几乎近似于刚接触swing的新手,在接下来的日子里简单记录一下学习swing的一些内容。以下,为swing中的关键,layout方面的内容。</p>
<h1 id="BorderLayout"><a href="#BorderLayout" class="headerlink" title="BorderLayout"></a>BorderLayout</h1><p>一种非常简单常用的布局策略, 也是某些容器组件的默认布局管理器,即RootPaneContainer(JInternalFrame、JDialog、JFrame、JWindow),它将容器分为NORTH, SOUTH,CENTER，WEST，EAST五个区域, 每个区域最多只能有一个组件. East和West的组件在垂直方向上拉升，North和South的组件在水平方向上拉升,Center的组件可同时在水平和垂直方向上拉升，填满所有剩余空间.</p>
<p>使用方式：</p>
<pre><code>Container.add（component, BorderLayout.EAST）;
</code></pre><p>例：</p>
<pre><code>    JFrame testFrame = new JFrame();
    testFrame.setSize(600, 600);
    testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JPanel contentPane = new JPanel();
    testFrame.setContentPane(contentPane);
    JButton button1 = new JButton(&quot;北&quot;);
    JButton button2 = new JButton(&quot;南&quot;);
    JButton button3 = new JButton(&quot;东&quot;);
    JButton button4 = new JButton(&quot;西&quot;);
    JButton button5 = new JButton(&quot;中央&quot;);
    testFrame.setLayout(new BorderLayout());
    contentPane.add(button1, &quot;North&quot;);
    contentPane.add(button2, &quot;South&quot;);
    contentPane.add(button3, &quot;East&quot;);
    contentPane.add(button4, &quot;West&quot;);
    contentPane.add(button5, &quot;Center&quot;);
    testFrame.setVisible(true);

// 具体可通过鼠标拖动窗体伸缩查看效果
</code></pre><p>显示:</p>
<p><img src="https://i.imgur.com/CUsBZWk.png" alt></p>
<p>若不指定第二个参数,则默认在BorderLayout.CENTER区域显示<br>如果对同一个区域添加了多个组件，那么只显示最后添加的组件。</p>
<h1 id="FlowLayout"><a href="#FlowLayout" class="headerlink" title="FlowLayout"></a>FlowLayout</h1><p>该布局是从左到右或从右到左方式排列，一行放不下就换到另外一行。因此它一行能放置多少组件取决于窗口的宽度。如果剩余空间小于组件，那么组件将在新行显示。注意它默认组件是居中对齐，可以通过FlowLayout(intalign)函数来指定对齐方式。是JPanel的默认的布局管理器</p>
<pre><code>import java.awt.FlowLayout;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class Test01 {

    public static void main(String[] args) {
        JFrame testFrame = new JFrame();
        testFrame.setSize(600, 600);
        testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JPanel panel = new JPanel();
        testFrame.setContentPane(panel);
        FlowLayout layout = new FlowLayout();
        testFrame.setLayout(layout);
        JButton button1 = new JButton(&quot;button1&quot;);
        JButton button2 = new JButton(&quot;button2&quot;);
        JButton button3 = new JButton(&quot;button3&quot;);
        JButton button4 = new JButton(&quot;button4&quot;);
        JButton button5 = new JButton(&quot;button5&quot;);
        panel.add(button1);
        panel.add(button2);
        panel.add(button3);
        panel.add(button4);
        panel.add(button5);
        testFrame.setVisible(true);
    }
}

// 具体可通过鼠标拖动窗体伸缩查看效果

注:
    // 设置组件之间的距离
    setVgap(int vgap) 设置组件之间以及组件与 Container 的边之间的垂直间隙。

    setHgap(int hgap) 设置组件之间以及组件与 Container 的边之间的水平间隙。
</code></pre><h1 id="GridLayout"><a href="#GridLayout" class="headerlink" title="GridLayout"></a>GridLayout</h1><p>网格式的布局,将整个容器划分成一定的行和一定的列，可以指定控件放在某行某列上,窗口改变的时候，组件的大小也会随之改变。每个单元格的大小一样，而且放置组件时，只能从左到右、由上到下的顺序填充，用户不能任意放置组件，比较的“死板”。 </p>
<p>简单一点来说, GridLayout就类似于一个标准的表格,但是最麻烦的是,这种布局不能跨行和跨列,所以感觉应该很少能用到这个布局方式。虽然可以在子组件中设置不同的布局方式进行搭配,使展示效果达到跨行跨列的效果,但是这已经与GridLayout没什么关系了</p>
<pre><code>GridLayout有三个构造方法

GridLayout() // 创建具有默认值的网格布局，即每个组件占据一行一列。
GridLayout(int rows, int cols) // 创建具有指定行数和列数的网格布局。
GridLayout(int rows, int cols, int hgap, int vgap) // 创建具有指定行数和列数的网格布局。

// 以GridLayout(int rows, int cols)为例：

    public static void main(String[] args) {
        JFrame testFrame = new JFrame();
        testFrame.setSize(600, 600);
        testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JPanel panel = new JPanel();
        testFrame.setContentPane(panel);
        GridLayout layout = new GridLayout(3,2);
        testFrame.setLayout(layout);
        JButton button1 = new JButton(&quot;button1&quot;);
        JButton button2 = new JButton(&quot;button2&quot;);
        JButton button3 = new JButton(&quot;button3&quot;);
        JButton button4 = new JButton(&quot;button4&quot;);
        JButton button5 = new JButton(&quot;button5&quot;);
        JButton button6 = new JButton(&quot;button6&quot;);
        panel.add(button1);
        panel.add(button2);
        panel.add(button3);
        panel.add(button4);
        panel.add(button5);
        panel.add(button6);
        testFrame.setVisible(true);
    }
</code></pre><p>显示：</p>
<p><img src="https://i.imgur.com/RLaXSX1.png" alt></p>
<h1 id="GridBagLayout"><a href="#GridBagLayout" class="headerlink" title="GridBagLayout"></a>GridBagLayout</h1><p>上面说GridLayout无法跨行和跨列,那么使用GridBagLayout就可以达到跨行跨列的效果,我想,在正式环境中应该使用GridBagLayout的情况反而更多。</p>
<p>GridBagLayout比较复杂,需要通过GridBagConstraints类进行约束。</p>
<p>GridBagConstraints常用方法：</p>
<pre><code>fill ：指定填充方向，可以向水平，垂直或水平+垂直方向充满整个容器
gridx(), gridy() 指定组件在容器单元格内的行索引与列索引，如最左上的那个单元格式，其gridx为0，gridy为0。
gridwidth(), gridheight() ：指定单元格的跨行与跨列数
insets ：指定组件的外部填充，相当于单元格间距
weightx, weighty ：指定容器大小变动时，向x或y方向的伸缩率。
Anchor：当组件的大小小于可用显示区域时使用，指定组件在显示区域中的位置。 请见下图：

    -------------------------------------------------
   |FIRST_LINE_START   PAGE_START     FIRST_LINE_END|
   |                                                |
   |                                                |
   |LINE_START           CENTER             LINE_END|
   |                                                |
   |                                                |
   |LAST_LINE_START     PAGE_END       LAST_LINE_END|
   ------------------------------------------------- 
</code></pre><p>以下给出一个GridBagLayout的例子：</p>
<pre><code>import java.awt.Button;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;

import javax.swing.JFrame;

public class GridBagLayoutTest {

    // 新建了一块场地
    private JFrame f = new JFrame(&quot;小区&quot;);
    // 聘请了一位资深的园艺设计师
    private GridBagLayout gb = new GridBagLayout();
    // 要设计，就要有一张空白的设计图纸
    private GridBagConstraints gbc = new GridBagConstraints();
    // 订购了十棵树
    private Button[] bs = new Button[11];

    public void init() {
        f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        f.setSize(1000, 1000);
        // 指定设计师要设计的地盘
        f.setLayout(gb);
        // 把十棵树先准备好
        for (int i = 0; i &lt; bs.length; i++) {
            bs[i] = new Button(&quot;树&quot; + i);
        }
        // 启用组件横向、纵向上扩展的功能
        gbc.fill = GridBagConstraints.BOTH;

        // 设置组件横向上扩展的比例，在一行上有多个组件时有用
        gbc.weightx = 1;

        // 中第一棵树
        addButton(bs[0]);
        // 中第二棵树
        addButton(bs[1]);
        addButton(bs[2]);

        // 中的第四棵树是这一行的最后一棵树
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        addButton(bs[3]);

        // 中的第五课树会从第二行开始,这棵树也是该行最后一棵树，增加纵向长度
        gbc.ipady = 20;
        addButton(bs[4]);

        // 从第三行开始种，横向占了两棵树的位置
        gbc.ipady = 0;
        gbc.gridwidth = 2;
        addButton(bs[5]);

        // 第三行的最后一棵树，自然横向占两棵树的位置
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        addButton(bs[6]);

        // 第四行第一棵树恢复横向占一棵树的位置
        gbc.gridwidth = 1;
        // 纵向跨越两个网格
        gbc.gridheight = 2;
        addButton(bs[7]);

        // 种第四行最后一棵树，自然横向跨越三棵树的位置
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        // 恢复纵向跨越一个网格
        gbc.gridheight = 1;
        addButton(bs[8]);
        // 接在第八棵树后面，但在第九棵树的下一行，真正实现了让第八棵树纵跨两行
        addButton(bs[9]);
        // 第十一课树会出现在第五行，因为没有给gridwidth重新赋值，它就是第五行最后一棵树
        // 将其设为纵向扩展，由于第十一棵树要纵向扩展，它会在上下两个方向不断膨胀，结果把它上面的组件都挤到
        // 最上面去了
        gbc.weighty = 1;
        addButton(bs[10]);
        // 使得场地的大小刚好容得下目前已种的树
//        f.pack();
        // 把设计好的场地展现出来
        f.setVisible(true);
    }

    // 将当前的树如何植入小区，植入小区哪边的方法
    private void addButton(Button button) {
        // 先要确保设计师手上有设计图纸和材料
        gb.setConstraints(button, gbc);
        // 将树植入
        f.add(button);
    }

    public static void main(String[] args) {
        new GridBagLayoutTest().init();
    }
}
</code></pre><p>// 以上这个例子是我在网上找资料的时候在一个论坛上看到的,感觉可以很好说明GridBagLayout.具体链接地址在哪里忘记了,惭愧。不过感谢那位仁兄对我的帮助</p>
<h1 id="CardLayout"><a href="#CardLayout" class="headerlink" title="CardLayout"></a>CardLayout</h1><p>CardLayout 对象是容器的布局管理器。它将容器中的每个组件看作一张卡片。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件</p>
<p>CardLayout的布局感觉有点像之前我记单词时用的单词卡一样,还有在有些APP中点击切切换页面可能也会使用到CardLayout. 其实个人感觉来说,这个布局就像是常用的Tab页,如JTabbedPane,去除头部标题那一部分的效果</p>
<h1 id="GroupLayout"><a href="#GroupLayout" class="headerlink" title="GroupLayout"></a>GroupLayout</h1><p>GroupLayout是一个非常复杂的Layout,此布局有一个轴的概念. 水平轴与垂直抽. 这个布局我很少接触,贴一些引用,待需要用到时再查找</p>
<ul>
<li><a href="https://blog.csdn.net/xietansheng/article/details/72862660" target="_blank" rel="noopener">JavaSwing_1.5: GroupLayout（分组布局）</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/group.html" target="_blank" rel="noopener">How to use GroupLayout</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/GroupLayout.html" target="_blank" rel="noopener">GroupLayout API</a></li>
</ul>
<p>例：</p>
<pre><code>public static void main(String[] args) {
    JFrame jf = new JFrame(&quot;测试窗口&quot;);
    jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    // 创建内容面板容器
    JPanel panel = new JPanel();
    // 创建分组布局，并关联容器
    GroupLayout layout = new GroupLayout(panel);
    // 设置容器的布局
    panel.setLayout(layout);

    // 创建组件
    JButton btn01 = new JButton(&quot;Button01&quot;);
    JButton btn02 = new JButton(&quot;Button02&quot;);
    JButton btn03 = new JButton(&quot;Button03&quot;);
    JButton btn04 = new JButton(&quot;Button04&quot;);
    JButton btn05 = new JButton(&quot;Button05&quot;);

    // 自动创建组件之间的间隙
    layout.setAutoCreateGaps(true);
    // 自动创建容器与触到容器边框的组件之间的间隙
    layout.setAutoCreateContainerGaps(true);

    /*
     * 水平组（仅确定 X 轴方向的坐标/排列方式）
     *
     * 水平串行: 水平排列（左右排列）
     * 水平并行: 垂直排列（上下排列）
     */
    // 水平并行（上下） btn01 和 btn02
    GroupLayout.ParallelGroup hParalGroup01 = layout.createParallelGroup().addComponent(btn01).addComponent(btn02);

    // 水平并行（上下）btn03 和 btn04
    GroupLayout.ParallelGroup hParalGroup02 = layout.createParallelGroup().addComponent(btn03).addComponent(btn04);

    // 水平串行（左右）hParalGroup01 和 hParalGroup02
    GroupLayout.SequentialGroup hSeqGroup = layout.createSequentialGroup().addGroup(hParalGroup01).addGroup(hParalGroup02);

    // 水平并行（上下）hSeqGroup 和 btn05
    GroupLayout.ParallelGroup hParalGroup = layout.createParallelGroup().addGroup(hSeqGroup).addComponent(btn05, GroupLayout.Alignment.CENTER);

    layout.setHorizontalGroup(hParalGroup);  // 指定布局的 水平组（水平坐标）

    /*
     * 垂直组（仅确定 Y 轴方向的坐标/排列方式）
     *
     * 垂直串行: 垂直排列（上下排列）
     * 垂直并行: 水平排列（左右排列）
     */
    // 垂直并行（左右）btn01 和 btn03
    GroupLayout.ParallelGroup vParalGroup01 = layout.createParallelGroup().addComponent(btn01).addComponent(btn03);

    // 垂直并行（左右）btn02 和 btn04
    GroupLayout.ParallelGroup vParalGroup02 = layout.createParallelGroup().addComponent(btn02).addComponent(btn04);

    // 垂直串行（上下）vParalGroup01, vParalGroup02 和 btn05
    GroupLayout.SequentialGroup vSeqGroup = layout.createSequentialGroup().addGroup(vParalGroup01).addGroup(vParalGroup02).addComponent(btn05);

    layout.setVerticalGroup(vSeqGroup);    // 指定布局的 垂直组（垂直坐标）

    jf.setContentPane(panel);
    jf.pack();
    jf.setLocationRelativeTo(null);
    jf.setVisible(true);
}
</code></pre><h1 id="BoxLayout"><a href="#BoxLayout" class="headerlink" title="BoxLayout"></a>BoxLayout</h1><p>BoxLayout也是一个比较强大的布局管理器, 它既可以设置横向排列页可以设置纵向排列。</p>
<p>主要排列方式包括</p>
<pre><code>X_AXIS：从左到右水平布置组件。

Y_AXIS：从上到下垂直布置组件。

LINE_AXIS：根据容器的ComponentOrientation属性，按照行的方式排列，可以从左到右也可以从右到左

PAGE_AXIS：根据容器的ComponentOrientation,以页面的方式进行排列
</code></pre><p>关于BoxLayout通常与Box容器进行搭配使用，Box可以创建一些影响布局的组件提高显示效果。glue、struts 和 rigid 区域。 比如有时候我们希望不同的组件之间留一些间隔，空白区域，我们就可以在不同的组件之间利用Box创建一些隐藏不可见的组件。</p>
<p>Box类常用方法：</p>
<pre><code>createHorizontalBox() // 创建一个从左到右显示其组件的 Box。

createVerticalBox() // 创建一个从上到下显示其组件的 Box。

createHorizontalGlue() // 创建一个横向 glue 组件。

createVerticalGlue() // 创建一个纵向 glue 组件。
</code></pre><p>关于Boxlayout在网上看到很多写的很好的博客，这里抛砖引入，使用其中一个例子：</p>
<pre><code>package boxlayout.test;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.table.DefaultTableModel;

public class BoxLayoutTest {

    static JPanel topPanel;
    static JPanel bottomPanel;
    static JPanel middlePanel;

    static void createTopPanel() {
        topPanel = new JPanel();
        String[] columnName = { &quot;姓名&quot;, &quot;性别&quot;, &quot;单位&quot;, &quot;参加项目&quot;, &quot;备注&quot; };
        String[][] rowData = { { &quot;张三&quot;, &quot;男&quot;, &quot;计算机系&quot;, &quot;100 米 ,200 米&quot;, &quot;&quot; }, { &quot;李四&quot;, &quot;男&quot;, &quot;化学系&quot;, &quot;100 米,铅球&quot;, &quot;&quot; }, };
        // 创建表格
        JTable table = new JTable(new DefaultTableModel(rowData, columnName));
        // 创建包含表格的滚动窗格
        JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        // 定义 topPanel 的布局为 BoxLayout,BoxLayout 为垂直排列
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        // 先加入一个不可见的 Strut,从而使 topPanel 对顶部留出一定的空间
        topPanel.add(Box.createVerticalStrut(10));
        // 加入包含表格的滚动窗格
        topPanel.add(scrollPane);
        // 再加入一个不可见的 Strut,从而使 topPanel 和 middlePanel 之间留出一定的空间
        topPanel.add(Box.createVerticalStrut(10));
    }

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    static void createMiddlePanel() {
        // 创建 middlePanel
        middlePanel = new JPanel();
        // 采用水平布局
        middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.X_AXIS));
        // 创建标签运动会项目
        JLabel sourceLabel = new JLabel(&quot;运动会项目：&quot;);
        sourceLabel.setAlignmentY(Component.TOP_ALIGNMENT);
        sourceLabel.setBorder(BorderFactory.createEmptyBorder(4, 5, 0, 5));
        // 创建列表运动会项目
        DefaultListModel listModel = new DefaultListModel();
        listModel.addElement(&quot;100 米&quot;);
        listModel.addElement(&quot;200 米&quot;);
        listModel.addElement(&quot;400 米&quot;);
        listModel.addElement(&quot;跳远&quot;);
        listModel.addElement(&quot;跳高&quot;);
        listModel.addElement(&quot;铅球&quot;);
        JList sourceList = new JList(listModel);
        sourceList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        sourceList.setVisibleRowCount(5);
        JScrollPane sourceListScroller = new JScrollPane(sourceList);
        sourceListScroller.setPreferredSize(new Dimension(120, 80));
        sourceListScroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        sourceListScroller.setAlignmentY(Component.TOP_ALIGNMENT);
        // 创建最左边的 Panel
        JPanel sourceListPanel = new JPanel();
        // 最左边的 Panel 采用水平布局
        sourceListPanel.setLayout(new BoxLayout(sourceListPanel, BoxLayout.X_AXIS));
        // 加入标签到最左边的 Panel
        sourceListPanel.add(sourceLabel);
        // 加入列表运动会项目到最左边的 Panel
        sourceListPanel.add(sourceListScroller);
        sourceListPanel.setAlignmentY(Component.TOP_ALIGNMENT);
        sourceListPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 30));
        // 将最左边的 Panel 加入到 middlePanel
        middlePanel.add(sourceListPanel);
        // 定义中间的两个按钮
        JButton toTargetButton = new JButton(&quot;&gt;&gt;&quot;);
        JButton toSourceButton = new JButton(&quot;&lt;&lt;&quot;);
        // 定义中间的 Panel
        JPanel buttonPanel = new JPanel();
        // 中间的 Panel 采用水平布局
        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
        // 将按钮 &gt;&gt; 加入到中间的 Panel
        buttonPanel.add(toTargetButton);

        // 两个按钮之间加入一个不可见的 rigidArea
        buttonPanel.add(Box.createRigidArea(new Dimension(15, 15)));
        // 将按钮 &lt;&lt; 加入到中间的 Panel
        buttonPanel.add(toSourceButton);
        buttonPanel.setAlignmentY(Component.TOP_ALIGNMENT);
        buttonPanel.setBorder(BorderFactory.createEmptyBorder(15, 5, 15, 5));
        // 将中间的 Panel 加入到 middlePanel
        middlePanel.add(buttonPanel);
        // 创建标签查询项目
        JLabel targetLabel = new JLabel(&quot;查询项目：&quot;);
        targetLabel.setAlignmentY(Component.TOP_ALIGNMENT);
        targetLabel.setBorder(BorderFactory.createEmptyBorder(4, 5, 0, 5));

        // 创建列表查询项目
        DefaultListModel targetListModel = new DefaultListModel();
        targetListModel.addElement(&quot;100 米&quot;);
        JList targetList = new JList(targetListModel);
        targetList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        targetList.setVisibleRowCount(5);
        JScrollPane targetListScroller = new JScrollPane(targetList);
        targetListScroller.setPreferredSize(new Dimension(120, 80));
        targetListScroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        targetListScroller.setAlignmentY(Component.TOP_ALIGNMENT);
        // 创建最右边的 Panel
        JPanel targetListPanel = new JPanel();
        // 设置最右边的 Panel 为水平布局
        targetListPanel.setLayout(new BoxLayout(targetListPanel, BoxLayout.X_AXIS));
        // 将标签查询项目加到最右边的 Panel
        targetListPanel.add(targetLabel);
        // 将列表查询项目加到最右边的 Panel
        targetListPanel.add(targetListScroller);
        targetListPanel.setAlignmentY(Component.TOP_ALIGNMENT);
        targetListPanel.setBorder(BorderFactory.createEmptyBorder(0, 30, 0, 0));
        // 最后将最右边的 Panel 加入到 middlePanel
        middlePanel.add(targetListPanel);
    }

    static void createBottomPanel() {
        // 创建查询按钮
        JButton actionButton = new JButton(&quot;查询&quot;);
        // 创建退出按钮
        JButton closeButton = new JButton(&quot;退出&quot;);
        // 创建 bottomPanel
        bottomPanel = new JPanel();
        // 设置 bottomPanel 为垂直布局
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        // 创建包含两个按钮的 buttonPanel
        JPanel buttonPanel = new JPanel();
        // 设置 bottomPanel 为水平布局
        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
        // 将查询按钮加入到 buttonPanel
        buttonPanel.add(actionButton);

        // 加入一个 glue, glue 会挤占两个按钮之间的空间
        buttonPanel.add(Box.createHorizontalGlue());
        // 将退出按钮加入到 buttonPanel
        buttonPanel.add(closeButton);
        // 加入一个 Strut,从而使 bottomPanel 和 middlePanel 上下之间留出距离
        bottomPanel.add(Box.createVerticalStrut(10));
        // 加入 buttonPanel
        bottomPanel.add(buttonPanel);
        // 加入一个 Strut,从而使 bottomPanel 和底部之间留出距离
        bottomPanel.add(Box.createVerticalStrut(10));
    }

    public static void main(String[] args) {
        // 创建 topPanel
        createTopPanel();
        // 创建 middlePanel
        createMiddlePanel();
        // 创建 bottomPanel
        createBottomPanel();
        // 创建包含 topPanel,middlePanel 和 bottomPanel 的 panelContainer
        JPanel panelContainer = new JPanel();
        // panelContainer 的布局为 GridBagLayout
        panelContainer.setLayout(new GridBagLayout());

        GridBagConstraints c1 = new GridBagConstraints();
        c1.gridx = 0;
        c1.gridy = 0;
        c1.weightx = 1.0;
        c1.weighty = 1.0;
        c1.fill = GridBagConstraints.BOTH;
        // 加入 topPanel
        panelContainer.add(topPanel, c1);

        GridBagConstraints c2 = new GridBagConstraints();
        c2.gridx = 0;
        c2.gridy = 1;
        c2.weightx = 1.0;
        c2.weighty = 0;
        c2.fill = GridBagConstraints.HORIZONTAL;
        // 加入 middlePanel
        panelContainer.add(middlePanel, c2);

        GridBagConstraints c3 = new GridBagConstraints();
        c3.gridx = 0;
        c3.gridy = 2;
        c3.weightx = 1.0;
        c3.weighty = 0;
        c3.fill = GridBagConstraints.HORIZONTAL;
        // 加入 bottomPanel
        panelContainer.add(bottomPanel, c3);

        // 创建窗体
        JFrame frame = new JFrame(&quot;Boxlayout 演示&quot;);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        panelContainer.setOpaque(true);
        frame.setSize(new Dimension(480, 320));
        frame.setContentPane(panelContainer);
        frame.setVisible(true);
    }
}
</code></pre><p>参考：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-boxlayout/" target="_blank" rel="noopener">运用 BoxLayout 进行 Swing 控件布局</a></p>
<p><a href="https://www.xuebuyuan.com/833030.html" target="_blank" rel="noopener">Swing框式布局（BoxLayout，Box）应用详解</a></p>
<h1 id="TableLayout"><a href="#TableLayout" class="headerlink" title="TableLayout"></a>TableLayout</h1><p>TableLayout不是JDK自带的布局管理器，使用TableLayout需要首先引入它的jar包， 如果是maven项目，可以在maven中央仓库找到这个jar包</p>
<p><a href="http://www.clearthought.info/sun/products/jfc/tsc/articles/tablelayout/javadoc/layout/TableLayout.html" target="_blank" rel="noopener">TabLayout API</a></p>
<p><a href="http://www.clearthought.info/sun/products/jfc/tsc/articles/tablelayout/index.html#WhatIs" target="_blank" rel="noopener">TableLayout官方使用说明</a></p>
<p>如果有需要还是去官方文档去查看好了，里面有很多小demo可供参考。</p>
<p>对于官方文档中，行和列的大小设置，在此添加一点说明。 Tablelayout设定行和列，需要先定义一个二维数组，举例如下：</p>
<pre><code>double size [] [] =
        {{100, 0.50,0.20，TableLayout.FILL，200，TableLayout.FILL}，
         {TableLayout.FILL}; 
</code></pre><p>其中size[0]设置的时列的宽度，size[1]设置的时列的高度。在宽度中有几个概念需要说明：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td>总宽度</td>
<td>顾名思义，即容器的总宽度 </td>
</tr>
<tr>
<td>绝对宽度</td>
<td>分配绝对像素大小的所有列的宽度成为绝对宽度 </td>
</tr>
<tr>
<td>可缩放宽度</td>
<td>可缩放宽度=总宽度-绝对宽度</td>
</tr>
<tr>
<td>绝对列</td>
<td>使用绝对宽度指定的列是绝对列 </td>
</tr>
<tr>
<td>可伸缩列</td>
<td>使用百分比指定的列称为可伸缩列</td>
</tr>
<tr>
<td>填充列</td>
<td>使用TableLayout.FILL指定</td>
</tr>
<tr>
<td>首选列</td>
<td>使用TableLayout.PREFERRED指定</td>
</tr>
</tbody>
</table>
<p>关于宽度的分配原则为：</p>
<p><strong>先将总宽度分配给绝对列和首选列，然后将剩余宽度（可伸缩宽度）分配给可伸缩列，如果可伸缩列的总和小于100％，则会留下一些可扩展的宽度。然后，在所有填充列中均等地划分该可缩放宽度</strong></p>
<p>还是照着上面的例子来看，上面使用了一个二维数组size[][]来定义当前容器的列。</p>
<ul>
<li>第0列： 100px (绝对宽度)</li>
<li>第1列： (500-100-200)*0.5 = 100px;</li>
<li>第2列： (500-100-200)*0.2 = 40px;</li>
<li>第3列： (500-100-200)*0.3/2 = 30px;</li>
<li>第4列： 200px(绝对宽度)</li>
<li>第5列： 同3列 30px;</li>
</ul>
<p>关于这个宽度计算，我之前看文档的时候被绕了一段事件才搞明白。写在这里以作参考</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于swing的布局策略，我的看法是，没有最好的layout，只有最适合当前业务场景的。能对不同的情况灵活选择，才是最好的。以上对一些常用的布局管理器进行了一些小小的总结，很多都是在网上查找资料是遇到的，我算是抛砖引玉了。当然，还有一些布局管理器没有说到，如：GridLayout，SpringLayout.等以后需要用到了再来查看吧。</p>
<p>另外留下SpringLayout的一些资源已备参考：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-mer09173/index.html" target="_blank" rel="noopener">SpringLayout 管理器</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/spring.html" target="_blank" rel="noopener">How to use SpringLayout</a></p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/SpringLayout.html" target="_blank" rel="noopener">SpringLayout API</a></p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/hthuang/p/3460234.html" target="_blank" rel="noopener">Java-Swing常用布局管理器</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/index.html" target="_blank" rel="noopener">官方使用文档</a></p>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>Java图形化</category>
        <category>Swing</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SWING</tag>
      </tags>
  </entry>
  <entry>
    <title>Dream</title>
    <url>/2018/08/28/Dream/</url>
    <content><![CDATA[<p>I don’t know what that dream is that you have. I don’t care how disappointing it might have been, as you’ve been working toward that dream.</p>
<p>That dream that you are holding in your mind that is possible. That some of you already know that is hard. It’s not easy.</p>
<p>It’s hard changing your life. That in the process of working on your dreams, you’re going to encounter a lot of disappointment, a lot of failure, a lot of pain. The moments when you’re going to doubt yourselves,ask god“why, why this happening to me. I am just trying to take care of my children and my mother. Am I trying to steal or rob from anybody? How does this have happened to me?”</p>
<p>For those of you that have experienced some hardships, don’t give up for your dream. There are right time on the way to have come, but they have not come to be seen, they have come to past.</p>
<p>Uniqueness is not this wonderful as all tell it delusive. God like featuring in that. Only the special among us are will ever take in something that truly exists in all of us.</p>
<p>It’s very important for you to believe that you are the one. Most people they raise their family, they earn their living and then they die.</p>
<p>They stop growing. They stop working on themselves. They stop stretching. They stop pushing themselves. That a lot of people like to complain but they don’t want to do anything about their situation. And most people don’t work on their dreams.</p>
<p>Why? One is because of the fear, the fear of failure. What if things don’t work out? And the fear of success, what if they do and I can’t handle it. These are not risk takers.    You spent so much time with other people. You spent so much time channel. You get other people to like you. You know other people more than you know yourselves. You study them. You know about them. You want to hang out like them. You want to be just like them. And you know what? Even better so much time and man, you don’t know who you are. I challenge you should spend time by yourselves.</p>
<p>It’s necessary that you get the losers out of your life if you want to live your dream. But people who are running toward their dreams, life has a special kind of meaning.    When you become the right person, what you do is to start separating yourselves from other people. You begin to have your certain uniqueness.</p>
<p>As long as you following other people, as long as you will be a copy cat. You will never ever be the best copy cat in the world. But you will be the best you could be. I challenge you could find your value. That everybody want to see it, that everybody want to join you, that everybody want to have a vision, it’s necessary to know that you are uncommon breed, it’s necessary you’re allowing yourselves with people who are trying to enter your business who are hungry, people who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more. The people who are living their dreams are fighting winners to attach themselves to .The people that are living their dreams are the people they know if it’s gonna happen, it’s up to them.</p>
<p>If you want to be more successful, if you want to have and don’t stop and never to be bored, let them all to invest in you, to invest in you, to invest in you.  Someone has the opinion that you do not have to become your reality, that you don’t have to go through life being a victim. Even though you face disappointment, you have to know within yourselves. Can I do it? Even no one sees it from me, I am gonna see it from myself.</p>
<p>This is what I believe and I am willing to die for, too. No matter how bad it is or how bad it gets, I am going to make it. I want to represent an ideal, I want to represent possibilities.  At some of you right now, you wanna be , you know I wanna go to the next level. I am gonna count so. I want to be an engineer, I want to be a doctor. Listen to me, you can get to that level, you can get to the level economically where you wanna be. And to use time you invest in mind, you are not reading books, I am telling you that all the books are the compasses.</p>
<p>I am telling you to invest time. I am telling you to be alone. I am telling you to spend out and get to know yourselves. When you become who you are, when you become the person that you are created to be, design to be who you’re designed to be. When you become an individual, what you do is you to take yourselves and you start submarine yourselves underpinned. I am telling you to get to a place where people don’t like you or bother you anymore. Why? Cause you are not consort with people and make them happy. Because you try more, you try to invest your mind.</p>
<p>But you still talk about your dream, you still talk about your goal, because we are not done that big, just taking footsteps. That you can make your parents proud, you can make your school proud, you can charge millions of people’s life. And the world will never be the same again, because you came this way. Don’t let anybody steal your dream. Have we face our rejections and we have a meeting and no one shows up? And somebody says you can count on me and they don’t come through. What if we have that kind of attitude we don’t possess. Nobody believes in you and you’ve lost again again and again. Your life has cut off, but you still looking at your grieve, revealing it every day and the singular step is not over.  </p>
<p>I tell I aware, you can live your dream!</p>
<blockquote>
<p>转自 2014全球最佳演讲「梦想」演讲稿</p>
</blockquote>
]]></content>
      <categories>
        <category>生活学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语 - 生活</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>使用iframe下载文件</title>
    <url>/2018/03/08/%E4%BD%BF%E7%94%A8iframe%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="使用iframe下载文件"><a href="#使用iframe下载文件" class="headerlink" title="使用iframe下载文件"></a>使用iframe下载文件</h1><p>   记录在工作中遇到的一个文件下载问题，之前使用的是a标签的download属性进行操作</p>
<p>   例：</p>
<pre><code>&lt;a href=&quot;/images/20180305.jpg&quot; download=&quot;1&quot;&gt;
</code></pre><p>   其中a标签的href对应下载文件的路径，download对应的是下载下来的文件名称</p>
<p>   但是download属性只支持 Firefox 和 Chrome，所以只能选择其他的方式解决。改成了使用iframe可以进行文件下载</p>
<p>   例：</p>
<pre><code>// 定义html标签
&lt;a href=&quot;#&quot; onclick=&quot;downloadPicture(url)&quot;&gt;imageName&lt;/a&gt;&apos;

// 在body中添加一个隐藏的iframe进行文件下载
&lt;script type=&quot;text/javascript&quot;&gt;
    function downloadPicture(url){
        $(&quot;#temp_iframe&quot;).remove();
        $(&quot;body&quot;).append(&quot;&lt;iframe id=&apos;temp_iframe&apos; style=&apos;display:none&apos;&gt;&lt;/iframe&gt;&quot;);
        document.getElementById(&apos;temp_iframe&apos;).src = contextPath+url);
    }
&lt;/script&gt;
</code></pre><p>   之前在这里还遇到了一个坑，项目使用的是struts2基于注解的方式进行下载的，页面写完js下载之后每次下载都是一个xxx.html的文件，后来发现原因，在struts注解下载中要特别注意指定filename，以下贴一大概的样例：</p>
<pre><code> /**
  * 文件下载
  *
  * @return
  * @throws Exception
  */
@Action(value = &quot;showWaterPicture&quot;,
    results = { @Result(name = SUCCESS, type = &quot;stream&quot;, params = {
        &quot;contentType&quot;,&quot;application/image/jpeg&quot;,
        &quot;inputName&quot;, &quot;inputStream&quot;,
        &quot;bufferSize&quot;, &quot;4096&quot;,
        &quot;contentDisposition&quot;,&quot;attachment;filename=${fileName}&quot;,
        &quot;contentCharSet&quot;, &quot;utf-8&quot; }) })
public String showWaterPicture() throws IOException {

     // 相关业务逻辑...
}
</code></pre>]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>java8函数式编程</title>
    <url>/2018/02/27/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li>FunctionalInterface注解</li>
<li>接口默认方法</li>
<li>Lambda表达式</li>
<li>方法引用</li>
</ol>
<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><p>Java8提供了函数式编程接口的概念。函数式接口：是只定义了<strong>单一抽象方法</strong>的接口，用作Lambda表达式的类型。如Runnable接口，就是一个典型的Functional Interface</p>
<pre><code>@FunctionalInterface
public interface Runnable {

    public abstract void run();
}
</code></pre><p>理解FunctionalInterface（函数式接口）是学习Java8 Lambda表达式的关键所在。函数式接口<strong>能且仅有一个抽象方法</strong>，而不是只能有一个方法。</p>
<h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>Java8之前版本接口只能包含抽象方法，Java8新增了接口的默认方法，接口也可以包含若干个实例方法。在Java8中，使用default关键字，可以在接口内定义实例方法，这个方法并非抽象方法，而是拥有特定逻辑的具体实例方法。</p>
<p>举个例子，鸟都会飞，定义接口Bird，包含一个默认方法fly()</p>
<pre><code>public interface Bird{

    void eat();

    default void fly() {
        System.out.println(&quot;bird can fly...&quot;);
    }
}
</code></pre><p>定义一个Crow类实现接口Bird。</p>
<pre><code>public class Crow implements Bird {

    @Override
    public void eat() {
        System.out.println(&quot;crow can eat&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>public class Test {
    public static void main(String[] args) {

        Crow crow = new Crow();

        crow.fly();
        crow.eat();
    }
}
</code></pre><p>输出结果：</p>
<p><img src="https://i.imgur.com/VvioxPf.png" alt></p>
<p>具体的类里面不是必须重写默认方法，这一改进使得Java8拥有了类似多继承的能力</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是函数式编程的核心。Lambda表达式即匿名函数，它是一段没有函数名的函数体，可以作为参数直接传递给相关的调用者。</p>
<p>还是拿Runnable为例：</p>
<pre><code>Runnable r = new Runnable() {
    public void run() {
        System.out.println(&quot;Hello World!&quot;);
    }
};
new Thread(r).start();
</code></pre><p>使用Lanbda表达式可以大大简化代码写法：</p>
<pre><code>new Thread(() -&gt; System.out.println(&quot;Hello World&quot;)).start();
</code></pre><p>输出结果：</p>
<p><img src="https://i.imgur.com/wZGKya3.png" alt>    </p>
<p>Lambda表达式语法：</p>
<ul>
<li><p>无参无返回值：</p>
<pre><code>() -&gt; { //..... };

如： Runnable r = () -&gt; {}
</code></pre></li>
<li><p>无参有返回值：</p>
<pre><code>() -&gt; {return something};

// 定义接口
@FunctionalInterface
public interface Bird {

    String eat();
}

// Lambda表达式可写为：

Bird bir = () -&gt; {return &quot;Hello World&quot;;};
</code></pre></li>
<li><p>有参有返回值：</p>
<pre><code>(param1,param2..paramN) -&gt; {return something};

如：
// 定义接口
@FunctionalInterface
public interface Bird {
    String eat(String str1,String str2);
}

Bird bird = (String apple,String orange) -&gt; {return &quot;吃饱了&quot;;};

如：
(int x, int y) -&gt; x + y
(int x, int y) -&gt; {return x + y;}
</code></pre></li>
<li><p>当lambda表达式只包含一条语句时，甚至可以省略大括号{}。</p>
<pre><code>param1 -&gt; statment
</code></pre></li>
</ul>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用是Java8中提出的用来简化Lambda表达式的一种手段，它通过类名和方法名来定位一个静态方法或者实例方法。方法引用使用”::”定义，”::”的前半部分表示类名或者实例名，后半部分表示方法名称，如果是构造器函数，则使用new表示。</p>
<ul>
<li><p>静态方法引用：ClassName::methodName</p>
<pre><code>List&lt;String&gt; strs = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;);
strs.forEach(System.out::println);    
</code></pre></li>
<li><p>实例方法引用：instanceRefence::methodName</p>
<pre><code>// 待更新...
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>技术开发</category>
        <category>Java</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
