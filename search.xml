<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个swing中添加右键菜单选项的小例子]]></title>
    <url>%2F2018%2F09%2F15%2Fswing%E5%8F%B3%E9%94%AE%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一个java右键添加菜单的小例子，乘着现在还有点印象，写下来以备以后需要。 import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.InputEvent; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import javax.swing.JFrame; import javax.swing.JMenuItem; import javax.swing.JPopupMenu; import javax.swing.JTextArea; import javax.swing.KeyStroke; import javax.swing.WindowConstants; public class Test02 { @SuppressWarnings(&quot;serial&quot;) class TextAreaMenu extends JTextArea{ // 菜单增加选项,复制,粘贴,剪切 JMenuItem copy = null, paste = null, cut = null; public TextAreaMenu(){ // 给当前组件添加右键菜单组件 JPopupMenu menu = new JPopupMenu(); menu.add(copy = new JMenuItem(&quot;复制&quot;)); menu.add(paste = new JMenuItem(&quot;粘贴&quot;)); menu.add(cut = new JMenuItem(&quot;剪切&quot;)); // 设置键盘操作 copy.setAccelerator(KeyStroke.getKeyStroke(&apos;C&apos;, InputEvent.CTRL_MASK)); paste.setAccelerator(KeyStroke.getKeyStroke(&apos;V&apos;, InputEvent.CTRL_MASK)); cut.setAccelerator(KeyStroke.getKeyStroke(&apos;X&apos;, InputEvent.CTRL_MASK)); this.addMouseListener(new MouseAdapter(){ // 当前组件的鼠标点击事件 @Override public void mouseClicked(MouseEvent e) { // MouseEvent.BUTTON1: 左键点击 // MouseEvent.BUTTON2: 中间点击(滑轮) if(e.getButton() == MouseEvent.BUTTON3){ // 设置右键点击事件,打开邮件菜单 menu.show(TextAreaMenu.this,e.getX(),e.getY()); // 设置选项是否可用 boolean isCanCopy = isCanCopy(); copy.setEnabled(isCanCopy); cut.setEnabled(isCanCopy); // 剪贴板是否存在数据 paste.setEnabled(isClipboardString()); } } }); // 初始化选项事件 initEvent(); } private void initEvent(){ copy.addActionListener(new ActionListener(){ @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;点击了复制按钮&quot;); TextAreaMenu.this.copy(); } }); paste.addActionListener(new ActionListener(){ @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;点击了粘贴按钮&quot;); TextAreaMenu.this.paste(); } }); cut.addActionListener(new ActionListener(){ @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;点击了剪切按钮&quot;); TextAreaMenu.this.cut(); } }); } /** * 当前文本组件是否可以复制 * true 具备 * false 不具备 * @return */ public boolean isCanCopy() { // getSelectionStart() 返回选定文本的起始位置。如果是空文档，则返回 0；如果没有选定，则返回点值。 int start = this.getSelectionStart(); // getSelectionEnd() 返回选定文本的结束位置。如果文本为空，则返回 0；如果没有选择，则返回点值。 int end = this.getSelectionEnd(); return start != end; } /** * 剪切板中是否有文本数据可供粘贴 * true 有文本数据 * false 无 * @return true为有文本数据 */ public boolean isClipboardString() { boolean b = false; // 获取剪贴板对象 Clipboard clipboard = this.getToolkit().getSystemClipboard(); try { // getContents(), 获取剪贴板对象中的数据对象,无则返回null Transferable content = clipboard.getContents(this); // getTransferData(), 获取数据对象中的值 if (content.getTransferData(DataFlavor.stringFlavor) instanceof String) { b = true; } } catch (Exception e) { return false; } return b; } } public static void main(String[] args) { JFrame jf = new JFrame(&quot;测试窗口&quot;); jf.setSize(600, 600); TextAreaMenu textAreaMenu = new Test02().new TextAreaMenu(); jf.setContentPane(textAreaMenu); jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); jf.setVisible(true); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SWING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swing布局]]></title>
    <url>%2F2018%2F09%2F13%2Fswing%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言swing是Java中的一个gui库。现在已经很少看到有使用swing开发的项目了.我也一直没有真正的使用swing进行开发,只是在刚接触java时根据例子简单敲了一下。不过最近,公司正好有一个项目是以swing为基础进行二次开发的,作为一个几乎近似于刚接触swing的新手,在接下来的日子里简单记录一下学习swing的一些内容。以下,为swing中的关键,layout方面的内容。 BorderLayout一种非常简单常用的布局策略, 也是某些容器组件的默认布局管理器,即RootPaneContainer(JInternalFrame、JDialog、JFrame、JWindow),它将容器分为NORTH, SOUTH,CENTER，WEST，EAST五个区域, 每个区域最多只能有一个组件. East和West的组件在垂直方向上拉升，North和South的组件在水平方向上拉升,Center的组件可同时在水平和垂直方向上拉升，填满所有剩余空间. 使用方式： Container.add（component, BorderLayout.EAST）; 例： JFrame testFrame = new JFrame(); testFrame.setSize(600, 600); testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel contentPane = new JPanel(); testFrame.setContentPane(contentPane); JButton button1 = new JButton(&quot;北&quot;); JButton button2 = new JButton(&quot;南&quot;); JButton button3 = new JButton(&quot;东&quot;); JButton button4 = new JButton(&quot;西&quot;); JButton button5 = new JButton(&quot;中央&quot;); testFrame.setLayout(new BorderLayout()); contentPane.add(button1, &quot;North&quot;); contentPane.add(button2, &quot;South&quot;); contentPane.add(button3, &quot;East&quot;); contentPane.add(button4, &quot;West&quot;); contentPane.add(button5, &quot;Center&quot;); testFrame.setVisible(true); // 具体可通过鼠标拖动窗体伸缩查看效果 显示: 若不指定第二个参数,则默认在BorderLayout.CENTER区域显示如果对同一个区域添加了多个组件，那么只显示最后添加的组件。 FlowLayout该布局是从左到右或从右到左方式排列，一行放不下就换到另外一行。因此它一行能放置多少组件取决于窗口的宽度。如果剩余空间小于组件，那么组件将在新行显示。注意它默认组件是居中对齐，可以通过FlowLayout(intalign)函数来指定对齐方式。是JPanel的默认的布局管理器 import java.awt.FlowLayout; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; public class Test01 { public static void main(String[] args) { JFrame testFrame = new JFrame(); testFrame.setSize(600, 600); testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); testFrame.setContentPane(panel); FlowLayout layout = new FlowLayout(); testFrame.setLayout(layout); JButton button1 = new JButton(&quot;button1&quot;); JButton button2 = new JButton(&quot;button2&quot;); JButton button3 = new JButton(&quot;button3&quot;); JButton button4 = new JButton(&quot;button4&quot;); JButton button5 = new JButton(&quot;button5&quot;); panel.add(button1); panel.add(button2); panel.add(button3); panel.add(button4); panel.add(button5); testFrame.setVisible(true); } } // 具体可通过鼠标拖动窗体伸缩查看效果 注: // 设置组件之间的距离 setVgap(int vgap) 设置组件之间以及组件与 Container 的边之间的垂直间隙。 setHgap(int hgap) 设置组件之间以及组件与 Container 的边之间的水平间隙。 GridLayout网格式的布局,将整个容器划分成一定的行和一定的列，可以指定控件放在某行某列上,窗口改变的时候，组件的大小也会随之改变。每个单元格的大小一样，而且放置组件时，只能从左到右、由上到下的顺序填充，用户不能任意放置组件，比较的“死板”。 简单一点来说, GridLayout就类似于一个标准的表格,但是最麻烦的是,这种布局不能跨行和跨列,所以感觉应该很少能用到这个布局方式。虽然可以在子组件中设置不同的布局方式进行搭配,使展示效果达到跨行跨列的效果,但是这已经与GridLayout没什么关系了 GridLayout有三个构造方法 GridLayout() // 创建具有默认值的网格布局，即每个组件占据一行一列。 GridLayout(int rows, int cols) // 创建具有指定行数和列数的网格布局。 GridLayout(int rows, int cols, int hgap, int vgap) // 创建具有指定行数和列数的网格布局。 // 以GridLayout(int rows, int cols)为例： public static void main(String[] args) { JFrame testFrame = new JFrame(); testFrame.setSize(600, 600); testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); testFrame.setContentPane(panel); GridLayout layout = new GridLayout(3,2); testFrame.setLayout(layout); JButton button1 = new JButton(&quot;button1&quot;); JButton button2 = new JButton(&quot;button2&quot;); JButton button3 = new JButton(&quot;button3&quot;); JButton button4 = new JButton(&quot;button4&quot;); JButton button5 = new JButton(&quot;button5&quot;); JButton button6 = new JButton(&quot;button6&quot;); panel.add(button1); panel.add(button2); panel.add(button3); panel.add(button4); panel.add(button5); panel.add(button6); testFrame.setVisible(true); } 显示： GridBagLayout上面说GridLayout无法跨行和跨列,那么使用GridBagLayout就可以达到跨行跨列的效果,我想,在正式环境中应该使用GridBagLayout的情况反而更多。 GridBagLayout比较复杂,需要通过GridBagConstraints类进行约束。 GridBagConstraints常用方法： fill ：指定填充方向，可以向水平，垂直或水平+垂直方向充满整个容器 gridx(), gridy() 指定组件在容器单元格内的行索引与列索引，如最左上的那个单元格式，其gridx为0，gridy为0。 gridwidth(), gridheight() ：指定单元格的跨行与跨列数 insets ：指定组件的外部填充，相当于单元格间距 weightx, weighty ：指定容器大小变动时，向x或y方向的伸缩率。 Anchor：当组件的大小小于可用显示区域时使用，指定组件在显示区域中的位置。 请见下图： ------------------------------------------------- |FIRST_LINE_START PAGE_START FIRST_LINE_END| | | | | |LINE_START CENTER LINE_END| | | | | |LAST_LINE_START PAGE_END LAST_LINE_END| ------------------------------------------------- 以下给出一个GridBagLayout的例子： import java.awt.Button; import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import javax.swing.JFrame; public class GridBagLayoutTest { // 新建了一块场地 private JFrame f = new JFrame(&quot;小区&quot;); // 聘请了一位资深的园艺设计师 private GridBagLayout gb = new GridBagLayout(); // 要设计，就要有一张空白的设计图纸 private GridBagConstraints gbc = new GridBagConstraints(); // 订购了十棵树 private Button[] bs = new Button[11]; public void init() { f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); f.setSize(1000, 1000); // 指定设计师要设计的地盘 f.setLayout(gb); // 把十棵树先准备好 for (int i = 0; i &lt; bs.length; i++) { bs[i] = new Button(&quot;树&quot; + i); } // 启用组件横向、纵向上扩展的功能 gbc.fill = GridBagConstraints.BOTH; // 设置组件横向上扩展的比例，在一行上有多个组件时有用 gbc.weightx = 1; // 中第一棵树 addButton(bs[0]); // 中第二棵树 addButton(bs[1]); addButton(bs[2]); // 中的第四棵树是这一行的最后一棵树 gbc.gridwidth = GridBagConstraints.REMAINDER; addButton(bs[3]); // 中的第五课树会从第二行开始,这棵树也是该行最后一棵树，增加纵向长度 gbc.ipady = 20; addButton(bs[4]); // 从第三行开始种，横向占了两棵树的位置 gbc.ipady = 0; gbc.gridwidth = 2; addButton(bs[5]); // 第三行的最后一棵树，自然横向占两棵树的位置 gbc.gridwidth = GridBagConstraints.REMAINDER; addButton(bs[6]); // 第四行第一棵树恢复横向占一棵树的位置 gbc.gridwidth = 1; // 纵向跨越两个网格 gbc.gridheight = 2; addButton(bs[7]); // 种第四行最后一棵树，自然横向跨越三棵树的位置 gbc.gridwidth = GridBagConstraints.REMAINDER; // 恢复纵向跨越一个网格 gbc.gridheight = 1; addButton(bs[8]); // 接在第八棵树后面，但在第九棵树的下一行，真正实现了让第八棵树纵跨两行 addButton(bs[9]); // 第十一课树会出现在第五行，因为没有给gridwidth重新赋值，它就是第五行最后一棵树 // 将其设为纵向扩展，由于第十一棵树要纵向扩展，它会在上下两个方向不断膨胀，结果把它上面的组件都挤到 // 最上面去了 gbc.weighty = 1; addButton(bs[10]); // 使得场地的大小刚好容得下目前已种的树 // f.pack(); // 把设计好的场地展现出来 f.setVisible(true); } // 将当前的树如何植入小区，植入小区哪边的方法 private void addButton(Button button) { // 先要确保设计师手上有设计图纸和材料 gb.setConstraints(button, gbc); // 将树植入 f.add(button); } public static void main(String[] args) { new GridBagLayoutTest().init(); } } // 以上这个例子是我在网上找资料的时候在一个论坛上看到的,感觉可以很好说明GridBagLayout.具体链接地址在哪里忘记了,惭愧。不过感谢那位仁兄对我的帮助 CardLayoutCardLayout 对象是容器的布局管理器。它将容器中的每个组件看作一张卡片。一次只能看到一张卡片，容器则充当卡片的堆栈。当容器第一次显示时，第一个添加到 CardLayout 对象的组件为可见组件 CardLayout的布局感觉有点像之前我记单词时用的单词卡一样,还有在有些APP中点击切切换页面可能也会使用到CardLayout. 其实个人感觉来说,这个布局就像是常用的Tab页,如JTabbedPane,去除头部标题那一部分的效果 GroupLayoutGroupLayout是一个非常复杂的Layout,此布局有一个轴的概念. 水平轴与垂直抽. 这个布局我很少接触,贴一些引用,待需要用到时再查找 JavaSwing_1.5: GroupLayout（分组布局） How to use GroupLayout GroupLayout API 例： public static void main(String[] args) { JFrame jf = new JFrame(&quot;测试窗口&quot;); jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); // 创建内容面板容器 JPanel panel = new JPanel(); // 创建分组布局，并关联容器 GroupLayout layout = new GroupLayout(panel); // 设置容器的布局 panel.setLayout(layout); // 创建组件 JButton btn01 = new JButton(&quot;Button01&quot;); JButton btn02 = new JButton(&quot;Button02&quot;); JButton btn03 = new JButton(&quot;Button03&quot;); JButton btn04 = new JButton(&quot;Button04&quot;); JButton btn05 = new JButton(&quot;Button05&quot;); // 自动创建组件之间的间隙 layout.setAutoCreateGaps(true); // 自动创建容器与触到容器边框的组件之间的间隙 layout.setAutoCreateContainerGaps(true); /* * 水平组（仅确定 X 轴方向的坐标/排列方式） * * 水平串行: 水平排列（左右排列） * 水平并行: 垂直排列（上下排列） */ // 水平并行（上下） btn01 和 btn02 GroupLayout.ParallelGroup hParalGroup01 = layout.createParallelGroup().addComponent(btn01).addComponent(btn02); // 水平并行（上下）btn03 和 btn04 GroupLayout.ParallelGroup hParalGroup02 = layout.createParallelGroup().addComponent(btn03).addComponent(btn04); // 水平串行（左右）hParalGroup01 和 hParalGroup02 GroupLayout.SequentialGroup hSeqGroup = layout.createSequentialGroup().addGroup(hParalGroup01).addGroup(hParalGroup02); // 水平并行（上下）hSeqGroup 和 btn05 GroupLayout.ParallelGroup hParalGroup = layout.createParallelGroup().addGroup(hSeqGroup).addComponent(btn05, GroupLayout.Alignment.CENTER); layout.setHorizontalGroup(hParalGroup); // 指定布局的 水平组（水平坐标） /* * 垂直组（仅确定 Y 轴方向的坐标/排列方式） * * 垂直串行: 垂直排列（上下排列） * 垂直并行: 水平排列（左右排列） */ // 垂直并行（左右）btn01 和 btn03 GroupLayout.ParallelGroup vParalGroup01 = layout.createParallelGroup().addComponent(btn01).addComponent(btn03); // 垂直并行（左右）btn02 和 btn04 GroupLayout.ParallelGroup vParalGroup02 = layout.createParallelGroup().addComponent(btn02).addComponent(btn04); // 垂直串行（上下）vParalGroup01, vParalGroup02 和 btn05 GroupLayout.SequentialGroup vSeqGroup = layout.createSequentialGroup().addGroup(vParalGroup01).addGroup(vParalGroup02).addComponent(btn05); layout.setVerticalGroup(vSeqGroup); // 指定布局的 垂直组（垂直坐标） jf.setContentPane(panel); jf.pack(); jf.setLocationRelativeTo(null); jf.setVisible(true); } BoxLayoutBoxLayout也是一个比较强大的布局管理器, 它既可以设置横向排列页可以设置纵向排列。 主要排列方式包括 X_AXIS：从左到右水平布置组件。 Y_AXIS：从上到下垂直布置组件。 LINE_AXIS：根据容器的ComponentOrientation属性，按照行的方式排列，可以从左到右也可以从右到左 PAGE_AXIS：根据容器的ComponentOrientation,以页面的方式进行排列 关于BoxLayout通常与Box容器进行搭配使用，Box可以创建一些影响布局的组件提高显示效果。glue、struts 和 rigid 区域。 比如有时候我们希望不同的组件之间留一些间隔，空白区域，我们就可以在不同的组件之间利用Box创建一些隐藏不可见的组件。 Box类常用方法： createHorizontalBox() // 创建一个从左到右显示其组件的 Box。 createVerticalBox() // 创建一个从上到下显示其组件的 Box。 createHorizontalGlue() // 创建一个横向 glue 组件。 createVerticalGlue() // 创建一个纵向 glue 组件。 关于Boxlayout在网上看到很多写的很好的博客，这里抛砖引入，使用其中一个例子： package boxlayout.test; import java.awt.Component; import java.awt.Dimension; import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import javax.swing.BorderFactory; import javax.swing.Box; import javax.swing.BoxLayout; import javax.swing.DefaultListModel; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JList; import javax.swing.JPanel; import javax.swing.JLabel; import javax.swing.JScrollPane; import javax.swing.JTable; import javax.swing.ListSelectionModel; import javax.swing.table.DefaultTableModel; public class BoxLayoutTest { static JPanel topPanel; static JPanel bottomPanel; static JPanel middlePanel; static void createTopPanel() { topPanel = new JPanel(); String[] columnName = { &quot;姓名&quot;, &quot;性别&quot;, &quot;单位&quot;, &quot;参加项目&quot;, &quot;备注&quot; }; String[][] rowData = { { &quot;张三&quot;, &quot;男&quot;, &quot;计算机系&quot;, &quot;100 米 ,200 米&quot;, &quot;&quot; }, { &quot;李四&quot;, &quot;男&quot;, &quot;化学系&quot;, &quot;100 米,铅球&quot;, &quot;&quot; }, }; // 创建表格 JTable table = new JTable(new DefaultTableModel(rowData, columnName)); // 创建包含表格的滚动窗格 JScrollPane scrollPane = new JScrollPane(table); scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); // 定义 topPanel 的布局为 BoxLayout,BoxLayout 为垂直排列 topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS)); // 先加入一个不可见的 Strut,从而使 topPanel 对顶部留出一定的空间 topPanel.add(Box.createVerticalStrut(10)); // 加入包含表格的滚动窗格 topPanel.add(scrollPane); // 再加入一个不可见的 Strut,从而使 topPanel 和 middlePanel 之间留出一定的空间 topPanel.add(Box.createVerticalStrut(10)); } @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) static void createMiddlePanel() { // 创建 middlePanel middlePanel = new JPanel(); // 采用水平布局 middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.X_AXIS)); // 创建标签运动会项目 JLabel sourceLabel = new JLabel(&quot;运动会项目：&quot;); sourceLabel.setAlignmentY(Component.TOP_ALIGNMENT); sourceLabel.setBorder(BorderFactory.createEmptyBorder(4, 5, 0, 5)); // 创建列表运动会项目 DefaultListModel listModel = new DefaultListModel(); listModel.addElement(&quot;100 米&quot;); listModel.addElement(&quot;200 米&quot;); listModel.addElement(&quot;400 米&quot;); listModel.addElement(&quot;跳远&quot;); listModel.addElement(&quot;跳高&quot;); listModel.addElement(&quot;铅球&quot;); JList sourceList = new JList(listModel); sourceList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); sourceList.setVisibleRowCount(5); JScrollPane sourceListScroller = new JScrollPane(sourceList); sourceListScroller.setPreferredSize(new Dimension(120, 80)); sourceListScroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); sourceListScroller.setAlignmentY(Component.TOP_ALIGNMENT); // 创建最左边的 Panel JPanel sourceListPanel = new JPanel(); // 最左边的 Panel 采用水平布局 sourceListPanel.setLayout(new BoxLayout(sourceListPanel, BoxLayout.X_AXIS)); // 加入标签到最左边的 Panel sourceListPanel.add(sourceLabel); // 加入列表运动会项目到最左边的 Panel sourceListPanel.add(sourceListScroller); sourceListPanel.setAlignmentY(Component.TOP_ALIGNMENT); sourceListPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 30)); // 将最左边的 Panel 加入到 middlePanel middlePanel.add(sourceListPanel); // 定义中间的两个按钮 JButton toTargetButton = new JButton(&quot;&gt;&gt;&quot;); JButton toSourceButton = new JButton(&quot;&lt;&lt;&quot;); // 定义中间的 Panel JPanel buttonPanel = new JPanel(); // 中间的 Panel 采用水平布局 buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS)); // 将按钮 &gt;&gt; 加入到中间的 Panel buttonPanel.add(toTargetButton); // 两个按钮之间加入一个不可见的 rigidArea buttonPanel.add(Box.createRigidArea(new Dimension(15, 15))); // 将按钮 &lt;&lt; 加入到中间的 Panel buttonPanel.add(toSourceButton); buttonPanel.setAlignmentY(Component.TOP_ALIGNMENT); buttonPanel.setBorder(BorderFactory.createEmptyBorder(15, 5, 15, 5)); // 将中间的 Panel 加入到 middlePanel middlePanel.add(buttonPanel); // 创建标签查询项目 JLabel targetLabel = new JLabel(&quot;查询项目：&quot;); targetLabel.setAlignmentY(Component.TOP_ALIGNMENT); targetLabel.setBorder(BorderFactory.createEmptyBorder(4, 5, 0, 5)); // 创建列表查询项目 DefaultListModel targetListModel = new DefaultListModel(); targetListModel.addElement(&quot;100 米&quot;); JList targetList = new JList(targetListModel); targetList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); targetList.setVisibleRowCount(5); JScrollPane targetListScroller = new JScrollPane(targetList); targetListScroller.setPreferredSize(new Dimension(120, 80)); targetListScroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); targetListScroller.setAlignmentY(Component.TOP_ALIGNMENT); // 创建最右边的 Panel JPanel targetListPanel = new JPanel(); // 设置最右边的 Panel 为水平布局 targetListPanel.setLayout(new BoxLayout(targetListPanel, BoxLayout.X_AXIS)); // 将标签查询项目加到最右边的 Panel targetListPanel.add(targetLabel); // 将列表查询项目加到最右边的 Panel targetListPanel.add(targetListScroller); targetListPanel.setAlignmentY(Component.TOP_ALIGNMENT); targetListPanel.setBorder(BorderFactory.createEmptyBorder(0, 30, 0, 0)); // 最后将最右边的 Panel 加入到 middlePanel middlePanel.add(targetListPanel); } static void createBottomPanel() { // 创建查询按钮 JButton actionButton = new JButton(&quot;查询&quot;); // 创建退出按钮 JButton closeButton = new JButton(&quot;退出&quot;); // 创建 bottomPanel bottomPanel = new JPanel(); // 设置 bottomPanel 为垂直布局 bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS)); // 创建包含两个按钮的 buttonPanel JPanel buttonPanel = new JPanel(); // 设置 bottomPanel 为水平布局 buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS)); // 将查询按钮加入到 buttonPanel buttonPanel.add(actionButton); // 加入一个 glue, glue 会挤占两个按钮之间的空间 buttonPanel.add(Box.createHorizontalGlue()); // 将退出按钮加入到 buttonPanel buttonPanel.add(closeButton); // 加入一个 Strut,从而使 bottomPanel 和 middlePanel 上下之间留出距离 bottomPanel.add(Box.createVerticalStrut(10)); // 加入 buttonPanel bottomPanel.add(buttonPanel); // 加入一个 Strut,从而使 bottomPanel 和底部之间留出距离 bottomPanel.add(Box.createVerticalStrut(10)); } public static void main(String[] args) { // 创建 topPanel createTopPanel(); // 创建 middlePanel createMiddlePanel(); // 创建 bottomPanel createBottomPanel(); // 创建包含 topPanel,middlePanel 和 bottomPanel 的 panelContainer JPanel panelContainer = new JPanel(); // panelContainer 的布局为 GridBagLayout panelContainer.setLayout(new GridBagLayout()); GridBagConstraints c1 = new GridBagConstraints(); c1.gridx = 0; c1.gridy = 0; c1.weightx = 1.0; c1.weighty = 1.0; c1.fill = GridBagConstraints.BOTH; // 加入 topPanel panelContainer.add(topPanel, c1); GridBagConstraints c2 = new GridBagConstraints(); c2.gridx = 0; c2.gridy = 1; c2.weightx = 1.0; c2.weighty = 0; c2.fill = GridBagConstraints.HORIZONTAL; // 加入 middlePanel panelContainer.add(middlePanel, c2); GridBagConstraints c3 = new GridBagConstraints(); c3.gridx = 0; c3.gridy = 2; c3.weightx = 1.0; c3.weighty = 0; c3.fill = GridBagConstraints.HORIZONTAL; // 加入 bottomPanel panelContainer.add(bottomPanel, c3); // 创建窗体 JFrame frame = new JFrame(&quot;Boxlayout 演示&quot;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); panelContainer.setOpaque(true); frame.setSize(new Dimension(480, 320)); frame.setContentPane(panelContainer); frame.setVisible(true); } } 参考： 运用 BoxLayout 进行 Swing 控件布局 Swing框式布局（BoxLayout，Box）应用详解 TableLayoutTableLayout不是JDK自带的布局管理器，使用TableLayout需要首先引入它的jar包， 如果是maven项目，可以在maven中央仓库找到这个jar包 TabLayout API TableLayout官方使用说明 如果有需要还是去官方文档去查看好了，里面有很多小demo可供参考。 对于官方文档中，行和列的大小设置，在此添加一点说明。 Tablelayout设定行和列，需要先定义一个二维数组，举例如下： double size [] [] = {{100, 0.50,0.20，TableLayout.FILL，200，TableLayout.FILL}， {TableLayout.FILL}; 其中size[0]设置的时列的宽度，size[1]设置的时列的高度。在宽度中有几个概念需要说明： 名称 含义 总宽度 顾名思义，即容器的总宽度 绝对宽度 分配绝对像素大小的所有列的宽度成为绝对宽度 可缩放宽度 可缩放宽度=总宽度-绝对宽度 绝对列 使用绝对宽度指定的列是绝对列 可伸缩列 使用百分比指定的列称为可伸缩列 填充列 使用TableLayout.FILL指定 首选列 使用TableLayout.PREFERRED指定 关于宽度的分配原则为： 先将总宽度分配给绝对列和首选列，然后将剩余宽度（可伸缩宽度）分配给可伸缩列，如果可伸缩列的总和小于100％，则会留下一些可扩展的宽度。然后，在所有填充列中均等地划分该可缩放宽度 还是照着上面的例子来看，上面使用了一个二维数组size[][]来定义当前容器的列。 第0列： 100px (绝对宽度) 第1列： (500-100-200)*0.5 = 100px; 第2列： (500-100-200)*0.2 = 40px; 第3列： (500-100-200)*0.3/2 = 30px; 第4列： 200px(绝对宽度) 第5列： 同3列 30px; 关于这个宽度计算，我之前看文档的时候被绕了一段事件才搞明白。写在这里以作参考 总结关于swing的布局策略，我的看法是，没有最好的layout，只有最适合当前业务场景的。能对不同的情况灵活选择，才是最好的。以上对一些常用的布局管理器进行了一些小小的总结，很多都是在网上查找资料是遇到的，我算是抛砖引玉了。当然，还有一些布局管理器没有说到，如：GridLayout，SpringLayout.等以后需要用到了再来查看吧。 另外留下SpringLayout的一些资源已备参考： SpringLayout 管理器 How to use SpringLayout SpringLayout API 参考： Java-Swing常用布局管理器 官方使用文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SWING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dream]]></title>
    <url>%2F2018%2F08%2F28%2Fdream%2F</url>
    <content type="text"><![CDATA[I don’t know what that dream is that you have. I don’t care how disappointing it might have been, as you’ve been working toward that dream. That dream that you are holding in your mind that is possible. That some of you already know that is hard. It’s not easy. It’s hard changing your life. That in the process of working on your dreams, you’re going to encounter a lot of disappointment, a lot of failure, a lot of pain. The moments when you’re going to doubt yourselves,ask god“why, why this happening to me. I am just trying to take care of my children and my mother. Am I trying to steal or rob from anybody? How does this have happened to me?” For those of you that have experienced some hardships, don’t give up for your dream. There are right time on the way to have come, but they have not come to be seen, they have come to past. Uniqueness is not this wonderful as all tell it delusive. God like featuring in that. Only the special among us are will ever take in something that truly exists in all of us. It’s very important for you to believe that you are the one. Most people they raise their family, they earn their living and then they die. They stop growing. They stop working on themselves. They stop stretching. They stop pushing themselves. That a lot of people like to complain but they don’t want to do anything about their situation. And most people don’t work on their dreams. Why? One is because of the fear, the fear of failure. What if things don’t work out? And the fear of success, what if they do and I can’t handle it. These are not risk takers. You spent so much time with other people. You spent so much time channel. You get other people to like you. You know other people more than you know yourselves. You study them. You know about them. You want to hang out like them. You want to be just like them. And you know what? Even better so much time and man, you don’t know who you are. I challenge you should spend time by yourselves. It’s necessary that you get the losers out of your life if you want to live your dream. But people who are running toward their dreams, life has a special kind of meaning. When you become the right person, what you do is to start separating yourselves from other people. You begin to have your certain uniqueness. As long as you following other people, as long as you will be a copy cat. You will never ever be the best copy cat in the world. But you will be the best you could be. I challenge you could find your value. That everybody want to see it, that everybody want to join you, that everybody want to have a vision, it’s necessary to know that you are uncommon breed, it’s necessary you’re allowing yourselves with people who are trying to enter your business who are hungry, people who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more. The people who are living their dreams are fighting winners to attach themselves to .The people that are living their dreams are the people they know if it’s gonna happen, it’s up to them. If you want to be more successful, if you want to have and don’t stop and never to be bored, let them all to invest in you, to invest in you, to invest in you. Someone has the opinion that you do not have to become your reality, that you don’t have to go through life being a victim. Even though you face disappointment, you have to know within yourselves. Can I do it? Even no one sees it from me, I am gonna see it from myself. This is what I believe and I am willing to die for, too. No matter how bad it is or how bad it gets, I am going to make it. I want to represent an ideal, I want to represent possibilities. At some of you right now, you wanna be , you know I wanna go to the next level. I am gonna count so. I want to be an engineer, I want to be a doctor. Listen to me, you can get to that level, you can get to the level economically where you wanna be. And to use time you invest in mind, you are not reading books, I am telling you that all the books are the compasses. I am telling you to invest time. I am telling you to be alone. I am telling you to spend out and get to know yourselves. When you become who you are, when you become the person that you are created to be, design to be who you’re designed to be. When you become an individual, what you do is you to take yourselves and you start submarine yourselves underpinned. I am telling you to get to a place where people don’t like you or bother you anymore. Why? Cause you are not consort with people and make them happy. Because you try more, you try to invest your mind. But you still talk about your dream, you still talk about your goal, because we are not done that big, just taking footsteps. That you can make your parents proud, you can make your school proud, you can charge millions of people’s life. And the world will never be the same again, because you came this way. Don’t let anybody steal your dream. Have we face our rejections and we have a meeting and no one shows up? And somebody says you can count on me and they don’t come through. What if we have that kind of attitude we don’t possess. Nobody believes in you and you’ve lost again again and again. Your life has cut off, but you still looking at your grieve, revealing it every day and the singular step is not over. I tell I aware, you can live your dream! 转自 2014全球最佳演讲「梦想」演讲稿]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我不爱我家]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%88%91%E4%B8%8D%E7%88%B1%E6%88%91%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[我不爱我家当我接到叔叔打过来的电话，说我爸中风了现在躺在医院里，我还有点迷，到底是个什么情况，是不是真的，现在在医院？还有，中风是什么，虽然听过很多新闻，说中风怎么样怎么样，不都是发生在老年人，七八十岁以上的人身上吗。然后我上网搜了一下，“中风的症状及后果”，影响智力，半身不遂，瘫痪?细想了一下，脑子有点蒙。马上买了一张车票回家。 在医院看到他那一刻，真的觉得有点不可思议，曾经那么健壮的一个人，躺在床上一动不动。上个月才回过家，他还好好的，还给我做了饭，前几天还通过电话，怎么一下子能让一个人变成这个模样。 其实我对我爸并没有什么感情，虽然看到他现在这个样子很难受的躺在床上，我只是机械的去做一些我觉得我该做的一些事情，比如在医院照顾他。只是尽一个人子做的简单的事情，心里并没有什么感觉。用我姑的话来说，我就是一个冷血动物，可能对待陌生人，朋友都比对我的家人好一些。 从小，我爸就一个人离家出去打工了，留下我妈和我两个人相依为命，然后我妈觉得在家也挣不到什么钱，呆在家跟我一起也没用，把我托付给外公外婆之后也出去打工了。所以我的童年对于父母是没什么感觉的。 打啊骂啊，在每年过年回来的那寥寥几天中发泄在我身上。可能别的小孩子在大人打的时候还会哭着跑开，我根本不会跑，也不会哭，因为我基本上一哭我妈会打我打的更凶。这也导致我现在从小到大基本上不会哭，哪怕眼泪一滴一滴的往下掉，也绝对不会发生一点声音。她打我的时候我就站在那里，随便她打。那时候还会想，你打吧打吧，你现在怎么样打我，以后我原原本本的还给你。 我爸是从我两岁的时候离家的，到我12岁左右的时候，才回来。期间，没有任何联系，没跟家人朋友有过任何联系。书信，电话，口信，什么都没有，然后，我妈经历了10年的等待之后，准备改嫁了。而正在筹备改嫁的事宜的时候，我爸突然回来了。真的感觉，人生好奇妙，我爸妈这事就像电影一样。不然怎么这么多事呢。然后，回来又怎么样呢，10年没见了哪还有什么感情，该改嫁还不是得嫁。 忘不了那天放学回家，院子里突然多了一个男人，然后身边的亲戚，都告诉我，那个是你爸，快叫爸爸，真的当时没有任何感觉。 我妈改嫁了，大人们问我愿意跟爸爸还是妈妈，虽然当时不太懂，但是只是觉得，我妈打了我这么多年，跟着她又能干什么呢，而且，跟着一个女人能成什么事，她都嫁人了，以后都不是一家人了，都不知道她以后会在那边过的怎么样，我还是不成她的拖油瓶了。所以我当时说我不跟我妈，其实我谁都不想跟，我觉得我一个人也能过的挺好，现在还有几年才到16，国家法定的，16岁以前都算童工，不能出去打工的。熬过这几年，等我16岁，我就出去打工，永远不再回来，我自己也能过好我自己。这个家本身没什么牵挂。可能唯一要报答的就是外公外婆的养育之恩了。以后出去工作了，努力一点，每年存点钱回来看望一下外公外婆，这是我当时心里的想法。 就这样，虽然我没选择跟我爸，但是还是把我给安排给了他。因为我如果继续跟着外公外婆的话，也还是会拖累他们,(当时外公外婆住在舅舅家里，舅舅舅妈说不同意老人家养我，说如果养我的话，他们也不会养外公外婆)。 就这样我跟接下来就属于跟着我爸了，读高中的时候虽然离家很近，但是我还是极力要求要去学校住宿，因为我不知道跟着一个陌生男人住一个家是什么感觉。 他负责我每年的学费及每个月的伙食费300块。在高中读了高二然后16岁了，期间虽然生活费本来就很少，但是还是省吃俭用，有时候不吃饭存点钱，当时一共存了400多块，然后就离家出走出去打工了，一直不回家，也不想跟他们有任何联系。所以算起来，我跟我爸在一起生活的时间寥寥无几，根本上谈不上什么感情。他其实对我并不好，喝酒，打牌，有几次直接把我踢倒在地上，最厉害的一次拿了把菜刀到我的面前，虽然起因是我到网吧上网被他抓到了。 回想这么些年，一个人在外面也习惯了，从来没什么跟家里联系一下的想法。一个人也挺好的，而且，回去也觉得有点尴尬，没什么感觉。虽然过了两三年后回去了一次，住了几天，但是心里没感觉。我从心里来说是有点讨厌我爸的，他跟我之间挂在嘴边最常说的一句话就是，等你到18岁我就不会管你了，随便你怎么样，是死是活都与我无关。呵呵，虽然都没那个必要让他养我到18岁。 当时心想的，我妈怎么打我我怎么还的想法现在早就没有了。从今年开始跟她又有一些联系了，不过毕竟不是一个家的人了，她也有自己的家庭，有自己的新的孩子，有自己的生活，我又能做什么呢，还是不要打扰她了。她能过好就过好，不能过好我也没什么办法。 写这篇日记的时候，我现在正在医院，刚给他换了裤子，他刚才又尿湿了。我已经几天几夜没好好休息过了，真的好累好难受。其实我心里来说是有点讨厌他的，为什么要出去打工，为什么那么多年为什么不跟家人联系，为什么要出这档子事，而且正在我正要开始发展的时候拖累我。冷静下来想一想，未来真的有点迷茫，虽然我觉得这些是我要做的，应该做的。但是心里竟然升不起一丝波澜。现在还是危险期，不管怎么样，希望他一切都好，尽快康复吧。不管他以后怎么样，做最坏的打算，以后就算瘫痪了，我也尽自己的一份力吧。细细想想，你可以对我不好，我还是得做我该做的，不然我和你有什么区别。一直陪在身边也是不现实的，没有收入，以后工作努力一点，每个月给他寄一点钱而已。 突然想起小时候老师布置的作文，题目“我爱我家”，“我的爸爸”，“我的妈妈”,到了我这里却从来不知道该写些什么。 生活总是充满波折，希望以后一切都好吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随便写写]]></title>
    <url>%2F2018%2F04%2F10%2F%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99%2F</url>
    <content type="text"><![CDATA[随便写写 又有很久没写日志了，感觉有点烦，最近人变的有点懒散。 清明假期 清明假期三天感觉过的飞快，就像小品里说的那样，一睁一闭，就有了，我好想这几天什么事情也没做。浑浑噩噩恍恍惚惚。 第一天小成同志在深圳，一起在欢乐谷逛了一下，虽然嘴上说不怕不怕，但是只要坐上那种在空中翻滚的项目都会有点心慌，说不出话来，强行抿嘴保持冷静；第二天，在家躺尸了一天；第三天睡了半天，然后去以前的钟柔印刷看了一下，请他们吃了个饭； 然后，又要上班了。。。 关于友情 小成同志这次来深圳，回去说瘦了3斤，有点感觉没招待好。这种他乡遇故知的感觉真的很好，可是我搞砸了。其实我一直把她当成我最好的几个朋友之一，我自己本身是个闷葫芦，对任何事都没什么兴趣，好像每天都活的很艰难，看不到乐趣的样子，不过她是个天生的乐天派，有时候她会无形的感染着我。当然，我并任何其他的想法。 想想现在，一起长大的小伙伴还有几个在联系呢，一起读书的同学，朋友，还有多少在联系呢？虽然话可能有点俗套，但是我确实经常还是会做白日梦，幻想这一切都是一个很遥远的梦，成长，工作都是浮云。我还是出现在那个朦胧的午后，在教室里，睡眼惺忪的睁开眼，周围都是熟悉的面孔，大家开开心心的。我也有机会改正自己，不再犯之后的一系列错误，好好读书，然后上大学，走上另一条道路。 加班无止境 最近做直饮水沁园项目，感觉很累，每天都在加班，看了一下自己的工作记录表，基本上工作日都在加班，周末也最起码加了一天，怕是要猝死了。其实如果大家一起加班的话，我觉得我都没什么，还是能坚持的，也不会有什么怨言，但是基本上是我一个人在加班，我觉得既然是一个团队的，要加班肯定是一起加班吧。而且最关键的一点，我加班改的bug还是由他们产生的，这就让我有点不爽了。不过想了一下，还是再坚持一下吧，做完这段时间反正也不想继续在这里呆着了。 关于离职 在过年的时候还没有任何离职的想法，可能对这个公司有一些看法和意见，但是并没有让我下定决心的地步。真正让我下定决心离职的一是听说老大也不想做了，项目组一个关系还不错的同事也不想做了，再一个有公司主动找上我了。综合在一起，加上最近加班，及其他一些心里积压已久的想法，还是决定要辞职了。虽然那边给我说的条件都还不错，但是从心里上来说还是不太想去的，现在的话，先忙过这一段时间，把工作交接好，以后就算不去那边继续面试找工作也可以的。不管怎么样，就算要走事情也还是得做好的。]]></content>
      <tags>
        <tag>生活</tag>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用iframe下载文件]]></title>
    <url>%2F2018%2F03%2F08%2F%E4%BD%BF%E7%94%A8iframe%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用iframe下载文件 记录在工作中遇到的一个文件下载问题，之前使用的是a标签的download属性进行操作 例： &lt;a href=&quot;/images/20180305.jpg&quot; download=&quot;1&quot;&gt; 其中a标签的href对应下载文件的路径，download对应的是下载下来的文件名称 但是download属性只支持 Firefox 和 Chrome，所以只能选择其他的方式解决。改成了使用iframe可以进行文件下载 例： // 定义html标签 &lt;a href=&quot;#&quot; onclick=&quot;downloadPicture(url)&quot;&gt;imageName&lt;/a&gt;&apos; // 在body中添加一个隐藏的iframe进行文件下载 &lt;script type=&quot;text/javascript&quot;&gt; function downloadPicture(url){ $(&quot;#temp_iframe&quot;).remove(); $(&quot;body&quot;).append(&quot;&lt;iframe id=&apos;temp_iframe&apos; style=&apos;display:none&apos;&gt;&lt;/iframe&gt;&quot;); document.getElementById(&apos;temp_iframe&apos;).src = contextPath+url); } &lt;/script&gt; 之前在这里还遇到了一个坑，项目使用的是struts2基于注解的方式进行下载的，页面写完js下载之后每次下载都是一个xxx.html的文件，后来发现原因，在struts注解下载中要特别注意指定filename，以下贴一大概的样例： /** * 文件下载 * * @return * @throws Exception */ @Action(value = &quot;showWaterPicture&quot;, results = { @Result(name = SUCCESS, type = &quot;stream&quot;, params = { &quot;contentType&quot;,&quot;application/image/jpeg&quot;, &quot;inputName&quot;, &quot;inputStream&quot;, &quot;bufferSize&quot;, &quot;4096&quot;, &quot;contentDisposition&quot;,&quot;attachment;filename=${fileName}&quot;, &quot;contentCharSet&quot;, &quot;utf-8&quot; }) }) public String showWaterPicture() throws IOException { // 相关业务逻辑... }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8函数式编程]]></title>
    <url>%2F2018%2F02%2F27%2Fjava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[FunctionalInterface注解 接口默认方法 Lambda表达式 方法引用 @FunctionalInterface注解Java8提供了函数式编程接口的概念。函数式接口：是只定义了单一抽象方法的接口，用作Lambda表达式的类型。如Runnable接口，就是一个典型的Functional Interface @FunctionalInterface public interface Runnable { public abstract void run(); } 理解FunctionalInterface（函数式接口）是学习Java8 Lambda表达式的关键所在。函数式接口能且仅有一个抽象方法，而不是只能有一个方法。 接口默认方法Java8之前版本接口只能包含抽象方法，Java8新增了接口的默认方法，接口也可以包含若干个实例方法。在Java8中，使用default关键字，可以在接口内定义实例方法，这个方法并非抽象方法，而是拥有特定逻辑的具体实例方法。 举个例子，鸟都会飞，定义接口Bird，包含一个默认方法fly() public interface Bird{ void eat(); default void fly() { System.out.println(&quot;bird can fly...&quot;); } } 定义一个Crow类实现接口Bird。 public class Crow implements Bird { @Override public void eat() { System.out.println(&quot;crow can eat&quot;); } } 测试： public class Test { public static void main(String[] args) { Crow crow = new Crow(); crow.fly(); crow.eat(); } } 输出结果： 具体的类里面不是必须重写默认方法，这一改进使得Java8拥有了类似多继承的能力 Lambda表达式Lambda表达式是函数式编程的核心。Lambda表达式即匿名函数，它是一段没有函数名的函数体，可以作为参数直接传递给相关的调用者。 还是拿Runnable为例： Runnable r = new Runnable() { public void run() { System.out.println(&quot;Hello World!&quot;); } }; new Thread(r).start(); 使用Lanbda表达式可以大大简化代码写法： new Thread(() -&gt; System.out.println(&quot;Hello World&quot;)).start(); 输出结果： Lambda表达式语法： 无参无返回值： () -&gt; { //..... }; 如： Runnable r = () -&gt; {} 无参有返回值： () -&gt; {return something}; // 定义接口 @FunctionalInterface public interface Bird { String eat(); } // Lambda表达式可写为： Bird bir = () -&gt; {return &quot;Hello World&quot;;}; 有参有返回值： (param1,param2..paramN) -&gt; {return something}; 如： // 定义接口 @FunctionalInterface public interface Bird { String eat(String str1,String str2); } Bird bird = (String apple,String orange) -&gt; {return &quot;吃饱了&quot;;}; 如： (int x, int y) -&gt; x + y (int x, int y) -&gt; {return x + y;} 当lambda表达式只包含一条语句时，甚至可以省略大括号{}。 param1 -&gt; statment 方法引用方法引用是Java8中提出的用来简化Lambda表达式的一种手段，它通过类名和方法名来定位一个静态方法或者实例方法。方法引用使用”::”定义，”::”的前半部分表示类名或者实例名，后半部分表示方法名称，如果是构造器函数，则使用new表示。 静态方法引用：ClassName::methodName List&lt;String&gt; strs = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;); strs.forEach(System.out::println); 实例方法引用：instanceRefence::methodName // 待更新...]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[很久以前就有一个想法要写一个博客了，今天终于开始有了属于自己的地盘了。 这里以后就是我的秘密基地，不单是记录平常工作中遇到的问题与学习笔记，跟会成为自己一个人发牢骚的地方。 2017不易，2018继续努力，朝着自己的目标奔跑. 2018，给自己定了三个目标 英语：英语成绩从L4要升到L8，这个level分级是在英孚报名时，英孚的分级。 复习：把java从头到尾复习一遍，还有其他的如spring，jquery，springmvc等方面的内容。虽然这个已经有很多人在做了，但是自己复习的还是自己的，不过结果怎么样，自己还是会去做这件事情 减肥：很久没有称量自己的体重了，最近买了个称称了一下才知道自己已经快180斤了，每天上班坐在那里，一坐就是一天，随便走一点路，都感觉有点气喘吁吁了。这个趋势下去有点不对啊，今年的目标是到150斤吧，我一定要坚持完成。少吃多动少吃多动少吃多动。 Everything is gonna be ok]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签测试文章]]></title>
    <url>%2F2018%2F02%2F20%2Farticle-title%2F</url>
    <content type="text"><![CDATA[未命名 !!!欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123 欢迎来到我的博客，这是我第一次创建博客，请多多指教啊123]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
